<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chess Rogue</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        * {
            box-sizing: border-box;
        }
        
        html, body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e;
            color: #e6e6e6;
            image-rendering: pixelated;
            width: 100vw;
            height: 100vh;
            min-height: 100vh;
            min-width: 100vw;
        }
        
        .pixel-art {
            image-rendering: pixelated;
        }
        
        .chess-board {
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 100vw;
            height: 100vw;
            max-width: 100vh;
            max-height: 100vh;
            aspect-ratio: 1/1;
            margin: 0;
            position: relative;
            flex-shrink: 0;
        }
        
        .light-square {
            background-color: #808080;
        }
        
        .dark-square {
            background-color: #800020;
        }
        
        .player {
            position: absolute;
            transition: all 0.3s ease;
        }
        
        .enemy {
            position: absolute;
        }

        .wall {
            position: absolute;
            image-rendering: pixelated;
        }
        
        .floor-square {
            position: absolute;
            image-rendering: pixelated;
        }

        .player.active {
            animation: pulse 1.5s infinite;
        }

        .attack-animation {
            animation: attack 0.3s;
        }

        @keyframes attack {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .damage-animation {
            animation: damage 0.5s;
        }

        @keyframes damage {
            0% { background-color: transparent; }
            50% { background-color: rgba(255, 0, 0, 0.5); }
            100% { background-color: transparent; }
        }
        
        .item {
            position: absolute;
            animation: float 2s ease-in-out infinite;
        }
        
        .exit {
            position: absolute;
            animation: glow 2s ease-in-out infinite;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        .exit.visible {
            opacity: 1;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }
        
        @keyframes glow {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .pixel-button {
            border: 2px solid #333;
            background-color: #4a4a4a;
            color: white;
            padding: 4px 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 6px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .pixel-button:hover {
            background-color: #5a5a5a;
            transform: translateY(-1px);
        }
        
        .pixel-button:active {
            transform: translateY(1px);
        }

        .available-move {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(0, 255, 0, 0.3);
            cursor: pointer;
            z-index: 10;
        }

        .available-move:hover {
            background-color: rgba(0, 255, 0, 0.5);
        }
        
        .pixel-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .pixel-button:hover::after {
            transform: translateX(0);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            overflow: hidden !important;
        }
        
        /* Улучшенные модальные окна в едином стиле */
        .modal-content {
            background: linear-gradient(145deg, #2d2d44, #1a1a2e);
            border: 4px solid #4a4a4a;
            border-radius: 12px;
            padding: 25px;
            max-width: 90vw;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .modal-title {
            font-size: 24px;
            color: gold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.3);
            margin-bottom: 20px;
            font-weight: bold;
            letter-spacing: 1px;
            text-align: center;
        }
        
        .modal-subtitle {
            font-size: 12px;
            color: #ccc;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-style: italic;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .modal-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .modal-section-title {
            font-size: 16px;
            color: gold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .modal-section-content {
            font-size: 11px;
            color: #ccc;
            line-height: 1.4;
        }
        
        .modal-section-content p {
            margin-bottom: 8px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        
        .modal-section-content .text-sm {
            font-size: 11px;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .modal-button {
            border: 3px solid #333;
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            color: white;
            padding: 10px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            border-radius: 6px;
        }
        
        .modal-button:hover {
            background: linear-gradient(145deg, #5a5a5a, #4a4a4a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: #666;
        }
        
        .modal-button:active {
            transform: translateY(0px);
        }
        
        .modal-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .modal-button:hover::after {
            transform: translateX(0);
        }
        
        /* Мобильная адаптация для модальных окон */
        @media (orientation: portrait) {
            .modal-content {
                padding: 20px;
                max-width: 95vw;
            }
            
            .modal-title {
                font-size: 20px;
                margin-bottom: 15px;
            }
            
            .modal-subtitle {
                font-size: 10px;
                margin-bottom: 15px;
            }
            
            .modal-section {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .modal-section-title {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            .modal-section-content {
                font-size: 10px;
            }
            
            .modal-section-content .text-sm {
                font-size: 10px;
            }
            
            .modal-button {
                font-size: 8px;
                padding: 8px 16px;
            }
        }
        
        @media (max-width: 400px) {
            .modal-content {
                padding: 15px;
                max-width: 98vw;
            }
            
            .modal-title {
                font-size: 18px;
                margin-bottom: 12px;
            }
            
            .modal-subtitle {
                font-size: 9px;
                margin-bottom: 12px;
            }
            
            .modal-section {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .modal-section-title {
                font-size: 12px;
                margin-bottom: 6px;
            }
            
            .modal-section-content {
                font-size: 9px;
            }
            
            .modal-section-content .text-sm {
                font-size: 9px;
            }
            
            .modal-button {
                font-size: 7px;
                padding: 6px 12px;
            }
        }
        
        .character-select {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            padding: 0 10px;
            width: 100%;
        }
        
        .character {
            width: 100%;
            height: 160px;
            border: 3px solid #4a4a4a;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(145deg, #2d2d44, #1a1a2e);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }
        
        .character:not(.locked) {
            border: 3px solid #666;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.05);
        }
        
        .character:not(.locked)::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 12px;
            background: linear-gradient(45deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .character:not(.locked):hover::after {
            opacity: 1;
        }
        
        .character.locked {
            cursor: not-allowed;
            opacity: 0.6;
            filter: grayscale(100%);
            border-color: #666;
        }
        
        .character.locked::after {
            content: '🔒';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 18px;
            color: #ff4444;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .character:hover:not(.locked) {
            transform: scale(1.03);
            border-color: #666;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        .character-image {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, #f0d9b5, #b58863);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            margin-bottom: 12px;
            border: 3px solid #333;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .character-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateX(-100%);
            animation: logo-shine 3s ease-in-out infinite;
        }
        
        .character.locked .character-image {
            filter: grayscale(100%);
            opacity: 0.7;
        }
        
        .character-name {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 1px;
        }
        
        .character-requirement {
            font-size: 9px;
            color: #ff6666;
            text-align: center;
            background: rgba(255, 0, 0, 0.15);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 0, 0, 0.4);
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            margin-bottom: 8px;
        }
        
        .character-stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: auto;
            font-size: 8px;
            color: #aaa;
            background: rgba(255, 255, 255, 0.05);
            padding: 6px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .stat-value {
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            font-size: 10px;
        }
        
        .stat-label {
            font-size: 6px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .character-select-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .character-select-title {
            font-size: 28px;
            color: gold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.3);
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .character-select-subtitle {
            font-size: 12px;
            color: #ccc;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-style: italic;
        }
        
        .progress-indicator {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            gap: 5px;
        }
        
        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #444;
            transition: all 0.3s ease;
            border: 2px solid #333;
        }
        
        .progress-dot.unlocked {
            background-color: gold;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
            border-color: #ffd700;
        }
        
        .character-select-footer {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .character-select-footer .pixel-button {
            min-width: 120px;
            font-size: 10px;
            padding: 8px 16px;
            border: 3px solid #333;
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            border-radius: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .character-select-footer .pixel-button:hover {
            background: linear-gradient(145deg, #5a5a5a, #4a4a4a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: #666;
        }
        
        .grayscale {
            filter: grayscale(100%);
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-between;
            background-color: #333;
            padding: 4px 8px;
            border-radius: 3px;
            margin-bottom: 5px;
            font-size: 8px;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 8px;
        }
        
        .inventory {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin-top: 3px;
            max-height: 40px;
            overflow-y: auto;
        }
        
        .inventory-item {
            width: 20px;
            height: 20px;
            background-color: #4a4a4a;
            border: 1px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .tooltip {
            position: absolute;
            background-color: #333;
            border: 1px solid #555;
            padding: 3px;
            z-index: 1000;
            font-size: 8px;
            pointer-events: none;
            display: none;
        }
        
        /* Мобильная адаптация */
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
            background-color: #333;
            border-radius: 0;
            margin-bottom: 0;
            font-size: 6px;
            flex-shrink: 0;
            min-height: 25px;
            max-height: 25px;
            overflow: hidden;
        }
        
        .game-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 0;
            min-height: 0;
            overflow: hidden;
            position: relative;
        }
        
        .game-sidebar {
            background-color: rgba(51, 51, 51, 0.9);
            padding: 4px;
            border-radius: 0;
            font-size: 6px;
            margin-bottom: 0;
            z-index: 10;
            flex-shrink: 0;
            min-height: 50px;
            max-height: 80px;
            overflow-y: auto;
        }
        
        .game-messages {
            background-color: rgba(51, 51, 51, 0.9);
            padding: 4px;
            border-radius: 0;
            font-size: 6px;
            flex-shrink: 0;
            z-index: 10;
            display: flex;
            flex-direction: column;
            min-height: 60px;
            max-height: 100px;
            overflow: hidden;
        }
        
        .message-log {
            font-size: 6px;
            line-height: 1.3;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 56px;
        }
        
        .header-stat {
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80px;
        }
        
        .header-stat-label {
            font-weight: bold;
            color: #ccc;
        }
        
        .header-stat-value {
            color: #fff;
            font-size: 7px;
            font-weight: bold;
        }
        
        @media (orientation: portrait) {
            .chess-board {
                width: 100vw;
                height: 100vw;
                max-width: 100vh;
                max-height: 100vh;
            }
            
            .game-sidebar {
                margin-bottom: 0;
                font-size: 8px;
                padding: 6px;
                min-height: 60px;
                max-height: 100px;
            }
            
            .game-messages {
                font-size: 8px;
                padding: 6px;
                min-height: 70px;
                max-height: 120px;
            }
            
            .message-log {
                font-size: 8px;
                max-height: 66px;
            }
            
            .game-header {
                font-size: 8px;
                padding: 4px 6px;
                min-height: 30px;
                max-height: 30px;
            }
            
            .header-stat {
                font-size: 8px;
                gap: 3px;
                max-width: 90px;
            }
            
            .header-stat-value {
                font-size: 9px;
            }
            
            .pixel-button {
                font-size: 8px;
                padding: 6px 10px;
            }
            
            .inventory-item {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }
            
            /* Character select mobile styles */
            .character-select {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .character {
                width: 80px;
                height: 100px;
                padding: 8px;
            }
            
            .character-image {
                width: 50px;
                height: 50px;
                font-size: 28px;
            }
            
            .character-name {
                font-size: 10px;
            }
            
            .character-description {
                font-size: 7px;
            }
            
            .character-requirement {
                font-size: 6px;
            }
            
            .character-stats {
                font-size: 5px;
            }
            
            .character-select-title {
                font-size: 20px;
            }
            
            .character-select-subtitle {
                font-size: 10px;
            }
            
            .character-select-footer .pixel-button {
                min-width: 100px;
                font-size: 8px;
                padding: 6px 12px;
            }
        }
        
        @media (max-width: 400px) {
            .chess-board {
                width: 100vw;
                height: 100vw;
                max-width: 100vh;
                max-height: 100vh;
            }
            
            .game-sidebar {
                font-size: 6px;
                padding: 4px;
                min-height: 50px;
                max-height: 80px;
            }
            
            .game-messages {
                font-size: 6px;
                padding: 4px;
                min-height: 60px;
                max-height: 100px;
            }
            
            .message-log {
                font-size: 6px;
                max-height: 56px;
            }
            
            .game-header {
                font-size: 6px;
                padding: 2px 4px;
                min-height: 25px;
                max-height: 25px;
            }
            
            .header-stat {
                font-size: 6px;
                gap: 2px;
                max-width: 75px;
            }
            
            .header-stat-value {
                font-size: 7px;
            }
            
            .pixel-button {
                font-size: 6px;
                padding: 4px 8px;
            }
            
            .inventory-item {
                width: 20px;
                height: 20px;
                font-size: 10px;
            }
            
            /* Character select small mobile styles */
            .character-select {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                width: 100%;
                padding: 0 5px;
            }
            
            .character {
                width: 100%;
                height: 120px;
                padding: 8px 6px;
                box-sizing: border-box;
            }
            
            .character-image {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
            
            .character-name {
                font-size: 8px;
            }
            
            .character-description {
                font-size: 6px;
            }
            
            .character-requirement {
                font-size: 5px;
            }
            
            .character-stats {
                font-size: 4px;
            }
            
            .character-select-title {
                font-size: 16px;
            }
            
            .character-select-subtitle {
                font-size: 8px;
            }
            
            .character-select-footer .pixel-button {
                min-width: 80px;
                font-size: 6px;
                padding: 4px 8px;
            }
        }
        
        /* Character Preview Modal - обновленный стиль */
        .character-preview {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }
        
        .preview-character-image {
            width: 100px;
            height: 100px;
            background: linear-gradient(145deg, #f0d9b5, #b58863);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            margin: 0 auto 20px;
            border: 3px solid #333;
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.3), 0 8px 16px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .preview-character-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateX(-100%);
            animation: logo-shine 3s ease-in-out infinite;
        }
        
        .preview-character-name {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            text-align: center;
        }
        
        .preview-character-description {
            font-size: 11px;
            color: #ccc;
            line-height: 1.4;
            margin-bottom: 15px;
            font-style: italic;
            text-align: center;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            }
        
        .preview-character-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .preview-stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        
        .preview-stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .preview-stat-label {
            font-size: 9px;
            color: #aaa;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        
        .preview-unlock-info {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 4px rgba(255, 0, 0, 0.1);
            text-align: center;
        }
        
        .preview-unlock-title {
            font-size: 12px;
            color: #ff6666;
            font-weight: bold;
            margin-bottom: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .preview-unlock-description {
            font-size: 10px;
            color: #ccc;
            line-height: 1.3;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        
        .modal-button.start {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border-color: #45a049;
        }
        
        .modal-button.start:hover {
            background: linear-gradient(145deg, #5cb85c, #4CAF50);
            border-color: #5cb85c;
        }
        
        .modal-button.start:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Мобильная адаптация для предварительного просмотра */
        @media (orientation: portrait) {
            .preview-character-image {
                width: 80px;
                height: 80px;
                font-size: 48px;
                margin-bottom: 15px;
            }
            
            .preview-character-name {
                font-size: 18px;
                margin-bottom: 8px;
            }
            
            .preview-character-description {
                font-size: 10px;
                margin-bottom: 12px;
            }
            
            .preview-character-stats {
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .preview-stat-item {
                padding: 8px;
            }
            
            .preview-stat-value {
                font-size: 14px;
            }
            
            .preview-stat-label {
                font-size: 8px;
            }
            
            .preview-unlock-info {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .preview-unlock-title {
                font-size: 11px;
            }
            
            .preview-unlock-description {
                font-size: 9px;
            }
        }
        
        @media (max-width: 400px) {
            .preview-character-image {
                width: 60px;
                height: 60px;
                font-size: 36px;
                margin-bottom: 12px;
            }
            
            .preview-character-name {
                font-size: 16px;
                margin-bottom: 6px;
            }
            
            .preview-character-description {
                font-size: 9px;
                margin-bottom: 10px;
            }
            
            .preview-character-stats {
                gap: 8px;
                margin-bottom: 12px;
            }
            
            .preview-stat-item {
                padding: 6px;
            }
            
            .preview-stat-value {
                font-size: 12px;
            }
            
            .preview-stat-label {
                font-size: 7px;
            }
            
            .preview-unlock-info {
                padding: 8px;
                margin-bottom: 12px;
            }
            
            .preview-unlock-title {
                font-size: 10px;
            }
            
            .preview-unlock-description {
                font-size: 8px;
            }
        }
        
        /* Улучшенное главное меню */
        .main-menu-content {
            background: linear-gradient(145deg, #2d2d44, #1a1a2e);
            border: 4px solid #4a4a4a;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .main-menu-title {
            font-size: 32px;
            color: gold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.5);
            margin-bottom: 20px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        .main-menu-logo {
            width: 120px;
            height: 120px;
            background: linear-gradient(145deg, #f0d9b5, #b58863);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            margin: 0 auto 25px;
            border: 4px solid #333;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.3), 0 8px 16px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .main-menu-logo::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateX(-100%);
            animation: logo-shine 3s ease-in-out infinite;
        }
        
        @keyframes logo-shine {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }
        
        .main-menu-subtitle {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-style: italic;
        }
        
        .main-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .main-menu-button {
            border: 3px solid #333;
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            color: white;
            padding: 12px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            border-radius: 6px;
        }
        
        .main-menu-button:hover {
            background: linear-gradient(145deg, #5a5a5a, #4a4a4a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: #666;
        }
        
        .main-menu-button:active {
            transform: translateY(0px);
        }
        
        .main-menu-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .main-menu-button:hover::after {
            transform: translateX(0);
        }
        
        .main-menu-button.danger {
            background: linear-gradient(145deg, #f44336, #d32f2f);
            border-color: #d32f2f;
        }
        
        .main-menu-button.danger:hover {
            background: linear-gradient(145deg, #ff5722, #f44336);
            border-color: #ff5722;
        }
        
        /* Мобильная адаптация для главного меню */
        @media (orientation: portrait) {
            .main-menu-content {
                padding: 25px;
                max-width: 350px;
        }
        
            .main-menu-title {
                font-size: 28px;
                margin-bottom: 15px;
            }
            
            .main-menu-logo {
                width: 100px;
                height: 100px;
                font-size: 50px;
                margin-bottom: 20px;
            }
            
            .main-menu-subtitle {
                font-size: 12px;
                margin-bottom: 25px;
            }
            
            .main-menu-button {
                font-size: 10px;
                padding: 10px 16px;
            }
        }
        
        @media (max-width: 400px) {
            .main-menu-content {
                padding: 20px;
                max-width: 300px;
            }
            
            .main-menu-title {
                font-size: 24px;
                margin-bottom: 12px;
            }
            
            .main-menu-logo {
                width: 80px;
                height: 80px;
                font-size: 40px;
                margin-bottom: 15px;
            }
            
            .main-menu-subtitle {
                font-size: 10px;
                margin-bottom: 20px;
            }
            
            .main-menu-button {
                font-size: 8px;
                padding: 8px 12px;
            }
        }
        
        /* Анимированные шахматные фигуры на фоне */
        .floating-piece {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 1;
            opacity: 0.3;
            image-rendering: pixelated;
        }
        
        .floating-piece.white {
            filter: brightness(1.2) contrast(1.1);
        }
        
        .floating-piece.black {
            filter: brightness(0.8) contrast(1.2);
        }
        
        .floating-piece.king {
            animation: float-king 8s ease-in-out infinite;
        }
        
        .floating-piece.queen {
            animation: float-queen 10s ease-in-out infinite;
        }
        
        .floating-piece.rook {
            animation: float-rook 12s ease-in-out infinite;
        }
        
        .floating-piece.bishop {
            animation: float-bishop 9s ease-in-out infinite;
        }
        
        .floating-piece.knight {
            animation: float-knight 11s ease-in-out infinite;
        }
        
        .floating-piece.pawn {
            animation: float-pawn 7s ease-in-out infinite;
        }
        
        @keyframes float-king {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-20px) rotate(5deg); }
            50% { transform: translateY(-10px) rotate(-3deg); }
            75% { transform: translateY(-15px) rotate(2deg); }
        }
        
        @keyframes float-queen {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-25px) rotate(-5deg); }
            66% { transform: translateY(-5px) rotate(3deg); }
        }
        
        @keyframes float-rook {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            20% { transform: translateY(-15px) rotate(2deg); }
            40% { transform: translateY(-30px) rotate(-2deg); }
            60% { transform: translateY(-20px) rotate(1deg); }
            80% { transform: translateY(-10px) rotate(-1deg); }
        }
        
        @keyframes float-bishop {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-18px) rotate(4deg); }
        }
        
        @keyframes float-knight {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-12px) rotate(-3deg); }
            50% { transform: translateY(-22px) rotate(2deg); }
            75% { transform: translateY(-8px) rotate(-1deg); }
        }
        
        @keyframes float-pawn {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-15px) rotate(1deg); }
        }
        
        /* Мобильная адаптация для выбора персонажа */
        @media (orientation: portrait) {
            .character-select {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                margin: 15px 0;
                padding: 0 8px;
            }
            
            .character {
                height: 160px;
                padding: 12px 8px;
            }
            
            .character-image {
                width: 60px;
                height: 60px;
                font-size: 36px;
                margin-bottom: 10px;
            }
            
            .character-name {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .character-requirement {
                font-size: 8px;
                padding: 3px 6px;
                margin-bottom: 6px;
            }
            
            .character-stats {
                padding: 5px;
                font-size: 7px;
            }
            
            .stat-value {
                font-size: 9px;
            }
            
            .stat-label {
                font-size: 5px;
            }
        }
        
        @media (max-width: 400px) {
            .character-select {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin: 12px 0;
                padding: 0 6px;
            }
            
            .character {
                height: 140px;
                padding: 10px 6px;
            }
            
            .character-image {
                width: 50px;
                height: 50px;
                font-size: 30px;
                margin-bottom: 8px;
            }
            
            .character-name {
                font-size: 12px;
                margin-bottom: 5px;
            }
            
            .character-requirement {
                font-size: 7px;
                padding: 2px 5px;
                margin-bottom: 5px;
            }
            
            .character-stats {
                padding: 4px;
                font-size: 6px;
            }
            
            .stat-value {
                font-size: 8px;
            }
            
            .stat-label {
                font-size: 4px;
            }
        }
        
        .character:not(.locked)::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }
        
        .character:not(.locked):hover::before {
            transform: translateX(100%);
        }

        /* Character select small mobile styles */
        .character-select {
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            width: 100% !important;
            padding: 0 5px;
            max-width: none !important;
        }
        
        .character {
            width: 100% !important;
            min-width: 0 !important;
            height: 120px;
            padding: 8px 6px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        
        /* Принудительные стили для мобильных карточек персонажей */
        @media (max-width: 400px) {
            .character-select {
                width: 100% !important;
                max-width: none !important;
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 8px !important;
                padding: 0 5px !important;
            }
            
            .character {
                width: 100% !important;
                min-width: 0 !important;
                max-width: none !important;
                height: 120px !important;
                padding: 8px 6px !important;
                box-sizing: border-box !important;
                flex-shrink: 0 !important;
            }
        }
        
        /* Скрываем статистику персонажей */
        .character-stats {
            display: none !important;
        }
        
        /* Стили для уведомления о разблокировке */
        .unlock-notification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .unlock-content {
            background: linear-gradient(145deg, #2d2d44, #1a1a2e);
            border: 4px solid gold;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 300px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
            animation: scaleIn 0.3s ease-out;
        }
        
        .unlock-icon {
            font-size: 48px;
            margin-bottom: 15px;
            animation: bounce 1s ease-in-out infinite;
        }
        
        .unlock-title {
            font-size: 18px;
            color: gold;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .unlock-message {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .unlock-button {
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            border: 2px solid #666;
            color: white;
            padding: 8px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .unlock-button:hover {
            background: linear-gradient(145deg, #5a5a5a, #4a4a4a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes scaleIn {
            from { transform: scale(0.8); }
            to { transform: scale(1); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu" class="modal flex">
        <div class="main-menu-content">
            <h1 class="main-menu-title">CHESS ROGUE</h1>
            <div class="main-menu-logo">
                ♔
            </div>
            <p class="main-menu-subtitle">A pixel roguelike chess adventure</p>
            <div class="main-menu-buttons">
                <button id="start-game" class="main-menu-button">NEW GAME</button>
                <button id="how-to-play" class="main-menu-button">HOW TO PLAY</button>
                <button id="credits" class="main-menu-button">CREDITS</button>
                <button id="reset-achievements" class="main-menu-button danger">RESET ACHIEVEMENTS</button>
            </div>
        </div>
    </div>
    
    <!-- Character Select -->
    <div id="character-select" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">SELECT YOUR PIECE</h2>
            <p class="modal-subtitle">Choose your champion and begin the adventure</p>
            
            <div class="progress-indicator">
                <div class="progress-dot unlocked" title="Pawn - Available"></div>
                <div class="progress-dot" title="Knight - Reach level 10"></div>
                <div class="progress-dot" title="Bishop - Complete level 15"></div>
                <div class="progress-dot" title="Rook - Promote 5 pawns"></div>
                <div class="progress-dot" title="Queen - Complete level 25"></div>
                <div class="progress-dot" title="King - Promote 3 pawns"></div>
                </div>
            
            <div class="character-select" id="character-select-grid">
                <!-- Characters will be dynamically generated here -->
                </div>
            
            <div class="modal-buttons">
                <button id="back-to-menu" class="modal-button">BACK TO MENU</button>
                </div>
                </div>
                </div>
    
    <!-- Character Preview Modal -->
    <div id="character-preview" class="character-preview">
        <div class="modal-content">
            <h2 class="modal-title">HERO PREVIEW</h2>
            <p class="modal-subtitle">Examine your chosen champion</p>
            
            <div class="preview-character-image" id="preview-character-image"></div>
            <div class="preview-character-name" id="preview-character-name"></div>
            <div class="preview-character-description" id="preview-character-description"></div>
            
            <div class="preview-character-stats" id="preview-character-stats">
                <!-- Stats will be generated here -->
                </div>
            
            <div class="preview-unlock-info" id="preview-unlock-info" style="display: none;">
                <div class="preview-unlock-title">LOCKED</div>
                <div class="preview-unlock-description" id="preview-unlock-description"></div>
            </div>
            
            <div class="modal-buttons">
                <button id="preview-back" class="modal-button">BACK</button>
                <button id="preview-start" class="modal-button start">START ADVENTURE</button>
            </div>
        </div>
    </div>
    
    <!-- How to Play -->
    <div id="how-to-play-modal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">HOW TO PLAY</h2>
            <p class="modal-subtitle">Master the art of chess roguelike combat</p>
            
            <div class="modal-section">
                <h3 class="modal-section-title">BASIC CONTROLS</h3>
                <div class="modal-section-content">
                    <p>• Click on your pieces to select and switch between them</p>
                    <p>• Each piece moves according to standard chess rules, except for the pawn, which moves 1 square in 4 direction</p>
                    <p>• Defeat all enemies to unlock the exit (🚪)</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">GAMEPLAY</h3>
                <div class="modal-section-content">
                    <p>• Start with one piece, collect more during your journey</p>
                    <p>• Defeat enemies to gain score</p>
                    <p>• Collect items: pieces, gold, effects, and special objects</p>
                    <p>• Pawns can promote after defeating 5 enemies (rare chance)</p>
                    <p>• Surviving pieces carry over to the next level</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">PIECES & MOVEMENT</h3>
                <div class="modal-section-content">
                    <p>• ♙ Pawn: Moves 1 square in 4 directions, captures diagonally</p>
                    <p>• ♘ Knight: L-shaped moves</p>
                    <p>• ♗ Bishop: Moves diagonally any distance</p>
                    <p>• ♖ Rook: Moves horizontally/vertically any distance</p>
                    <p>• ♕ Queen: Combines Bishop and Rook movements</p>
                    <p>• ♔ King: Moves 1 square in any direction</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">ITEMS & EFFECTS</h3>
                <div class="modal-section-content">
                    <p>• 🪙 Gold: Currency for shop and slot machine</p>
                    <p>• ⭐ Stars: Random temporary effects</p>
                    <p>• 💎 Diamonds: High-value gold items</p>
                    <p>• 📦 Chests: Random rewards</p>
                    <p>• 🎰 Slot Machine: Spend 10 gold for prizes</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">SHOP & PROGRESSION</h3>
                <div class="modal-section-content">
                    <p>• Shop appears every 2 levels with 4 random items</p>
                    <p>• Buy pieces, effects, or revive fallen pieces</p>
                    <p>• Unlock new starting pieces through achievements</p>
                    <p>• Coordinate system (A1-H8) helps track moves</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">ACHIEVEMENTS</h3>
                <div class="modal-section-content">
                    <p>• Knight: Reach level 10</p>
                    <p>• Bishop: Complete level 15</p>
                    <p>• Rook: Promote 5 pawns</p>
                    <p>• Queen: Complete level 25</p>
                    <p>• King: Promote 3 pawns</p>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="close-how-to-play" class="modal-button">BACK</button>
            </div>
        </div>
    </div>
    
    <!-- Credits -->
    <div id="credits-modal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">CREDITS</h2>
            <p class="modal-subtitle">The minds behind Chess Rogue</p>
            
            <div class="modal-section">
                <h3 class="modal-section-title">DEVELOPED BY</h3>
                <div class="modal-section-content">
                    <p>Chess Rogue Team</p>
                    <p>Pixel Art & Game Design</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">SPECIAL THANKS</h3>
                <div class="modal-section-content">
                    <p>• Chess enthusiasts everywhere</p>
                    <p>• Roguelike fans</p>
                    <p>• Pixel art lovers</p>
                    <p>• The chess community</p>
                    <p>• All beta testers</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">TECHNOLOGY</h3>
                <div class="modal-section-content">
                    <p>• HTML5 Canvas & JavaScript</p>
                    <p>• Pixel-perfect rendering</p>
                    <p>• Mobile-first design</p>
                    <p>• Progressive Web App</p>
                </div>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">VERSION</h3>
                <div class="modal-section-content">
                    <p>Chess Rogue v1.0</p>
                    <p>Epic Edition</p>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="close-credits" class="modal-button">BACK</button>
            </div>
        </div>
    </div>
    
    <!-- Game Over -->
    <div id="game-over-modal" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl mb-3" style="color: red;">GAME OVER</h2>
            <p id="final-score" class="mb-4 text-sm">You reached level <span id="final-level">1</span> with a score of <span id="final-score-value">0</span></p>
            <div class="flex justify-center gap-3">
                <button id="restart-game" class="pixel-button">TRY AGAIN</button>
                <button id="revive-button" class="pixel-button" style="background-color: #4CAF50;" disabled>REVIVE</button>
                <button id="game-over-to-menu" class="pixel-button">MAIN MENU</button>
            </div>
        </div>
    </div>
    
    <!-- Level Complete -->
    <div id="level-complete-modal" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl mb-3" style="color: gold;">LEVEL COMPLETE!</h2>
            <p id="level-rewards" class="mb-4 text-sm">You found <span id="level-gold">0</span> gold and <span id="level-items">0</span> items</p>
            <div class="flex justify-center">
                <button id="next-level" class="pixel-button">CONTINUE</button>
            </div>
        </div>
    </div>
    
    <!-- Shop Modal -->
    <div id="shop-modal" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl mb-3" style="color: gold;">SHOP</h2>
            <p class="mb-4 text-sm">Your gold: <span id="shop-gold">0</span></p>
            <div id="shop-items" class="grid grid-cols-2 gap-4 mb-4">
                <!-- Shop items will be generated here -->
                </div>
            <div class="flex justify-center gap-3">
                <button id="shop-skip" class="pixel-button">SKIP</button>
                <button id="shop-slot" class="pixel-button">🎰 (10G)</button>
                <button id="shop-continue" class="pixel-button">CONTINUE</button>
                </div>
                </div>
                </div>
    
    <!-- Slot Machine Modal -->
    <div id="slot-machine-modal" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl mb-3" style="color: gold;">🎰 SLOT MACHINE</h2>
            <p class="mb-4 text-sm">Cost: 10 gold | Your gold: <span id="slot-gold">0</span></p>
            <div id="slot-reels" class="mb-4" style="display: flex; justify-content: center; gap: 10px; min-height: 80px; align-items: center;">
                <div id="slot-reel-1" class="slot-reel" style="font-size: 48px; width: 60px; height: 60px; border: 2px solid #666; display: flex; align-items: center; justify-content: center; background: #2a2a2a;">❓</div>
                <div id="slot-reel-2" class="slot-reel" style="font-size: 48px; width: 60px; height: 60px; border: 2px solid #666; display: flex; align-items: center; justify-content: center; background: #2a2a2a;">❓</div>
                <div id="slot-reel-3" class="slot-reel" style="font-size: 48px; width: 60px; height: 60px; border: 2px solid #666; display: flex; align-items: center; justify-content: center; background: #2a2a2a;">❓</div>
            </div>
            <div class="flex justify-center gap-3">
                <button id="slot-spin" class="pixel-button">SPIN (10G)</button>
                <button id="slot-close" class="pixel-button">CLOSE</button>
            </div>
                </div>
            </div>
            
    <!-- Slot Prize Modal -->
    <div id="slot-prize-modal" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl mb-3" style="color: gold;">🎁 PRIZE!</h2>
            <div id="prize-content" class="mb-4" style="font-size: 48px; min-height: 80px; display: flex; align-items: center; justify-content: center;">
                🎁
            </div>
            <div id="prize-text" class="mb-4 text-lg">
                You won a prize!
            </div>
            <button id="prize-close" class="pixel-button">COLLECT</button>
        </div>
                </div>
                
    <!-- Game UI -->
    <div id="game-container" class="hidden game-container">
        <div class="game-header">
            <div class="flex gap-2 text-xs" style="flex-wrap: nowrap; overflow: hidden;">
                <div class="header-stat">
                    <span class="header-stat-label">Level:</span>
                    <span class="header-stat-value" id="current-level">1</span>
                </div>
                <div class="header-stat">
                    <span class="header-stat-label">Score:</span>
                    <span class="header-stat-value" id="current-score">0</span>
                </div>
                <div class="header-stat">
                    <span class="header-stat-label">Gold:</span>
                    <span class="header-stat-value" id="current-gold">0</span>
                </div>
                <div class="header-stat">
                    <span class="header-stat-value" id="current-attack">pawn</span>
                </div>
            </div>
            <button id="open-menu" class="pixel-button" style="flex-shrink: 0;">MENU</button>
                    </div>
                    
        <div class="game-sidebar">
            <h3 class="text-xs mb-2">ACTIVE EFFECTS</h3>
                    <div class="inventory" id="inventory">
                        <!-- Active effects will appear here -->
                    </div>
                    </div>
                    
        <div class="game-main">
            <div class="relative chess-board" id="game-board">
                <!-- Game board will be generated here -->
                </div>
            </div>
            
        <div class="game-messages">
            <h3 class="text-xs mb-1">MESSAGES</h3>
            <div id="message-log" class="message-log">
                    <!-- Game messages will appear here -->
            </div>
        </div>
    </div>
    
    <!-- In-Game Menu -->
    <div id="in-game-menu" class="modal hidden">
        <div class="modal-content text-center">
            <h2 class="text-xl mb-6">GAME MENU</h2>
            <div class="flex flex-col gap-3">
                <button id="resume-game" class="pixel-button">RESUME</button>
                <button id="concede-game" class="pixel-button" style="background-color: #f44336;">CONCEDE</button>
                <button id="return-to-menu" class="pixel-button">RETURN TO MENU</button>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Get piece image path based on piece type and color
        function getPieceImagePath(pieceType, isPlayer = true) {
            const color = isPlayer ? 'white' : 'black';
            switch(pieceType) {
                case 'pawn': return `assets/sprites/figures/${color}/pawn.png`;
                case 'knight': return `assets/sprites/figures/${color}/knight.png`;
                case 'bishop': return `assets/sprites/figures/${color}/bishop.png`;
                case 'rook': return `assets/sprites/figures/${color}/rook.png`;
                case 'queen': return `assets/sprites/figures/${color}/queen.png`;
                case 'king': return `assets/sprites/figures/${color}/king.png`;
                default: return `assets/sprites/figures/${color}/pawn.png`;
            }
        }
        
        // Get random wall sprite
        function getRandomWallSprite() {
            const wallSprites = [
                'wall_1.png',
                'wall_2.png', 
                'wall_3.png',
                'wall_crack.png'
            ];
            return `assets/sprites/walls/${wallSprites[Math.floor(Math.random() * wallSprites.length)]}`;
        }
        
        // Get left side wall sprite
        function getLeftWallSprite() {
            return 'assets/sprites/walls/wall_side_left .png';
        }
        
        // Get right side wall sprite
        function getRightWallSprite() {
            return 'assets/sprites/walls/wall_side_right.png';
        }
        
        // Get floor sprite based on square type
        function getFloorSprite(isLightSquare) {
            return isLightSquare ? 'assets/sprites/floor/floor_3.png' : 'assets/sprites/floor/floor_4.png';
        }
        
        // Get stair sprite for next level
        function getStairSprite() {
            return 'assets/sprites/floor/stair_nextlevel.png';
        }
        
        // Get item figure sprite based on piece type
        function getItemFigureSprite(pieceType) {
            switch(pieceType) {
                case 'pawn': return 'assets/sprites/items/figures/pawn.png';
                case 'knight': return 'assets/sprites/items/figures/knight.png';
                case 'bishop': return 'assets/sprites/items/figures/bishop.png';
                case 'rook': return 'assets/sprites/items/figures/rook.png';
                case 'queen': return 'assets/sprites/items/figures/queen.png';
                default: return 'assets/sprites/items/figures/pawn.png';
            }
        }
        
        // Get item sprite based on item type
        function getItemSprite(itemType) {
            switch(itemType) {
                case 'gold': return 'assets/sprites/items/coin.png';
                case 'mystery': return 'assets/sprites/items/mystery.png';
                case 'chest': return 'assets/sprites/items/chest.png';
                case 'slot': return 'assets/sprites/items/slot.png';
                default: return 'assets/sprites/items/coin.png';
            }
        }
        
        // Get effect sprite based on effect type
        function getEffectSprite(effectType) {
            switch(effectType) {
                case 'ai_disabled': return 'assets/sprites/items/decrease.png';
                case 'master_key': return 'assets/sprites/items/Golden Key.png';
                case 'chaos_mode': return 'assets/sprites/items/chaos.png';
                case 'double_ai': return 'assets/sprites/items/increase.png';
                case 'gold_boost': return 'assets/sprites/items/gold magnet.png';
                case 'score_boost': return 'assets/sprites/items/score multiplier.png';
                case 'shop_discount': return 'assets/sprites/items/shop discount.png';
                case 'shop_markup': return 'assets/sprites/items/shop markup.png';
                case 'add_gold': return 'assets/sprites/items/gold rush.png';
                case 'add_score': return 'assets/sprites/items/score boost.png';
                case 'level_skip': return 'assets/sprites/items/level skip.png';
                case 'random_piece': return 'assets/sprites/items/random piece.png';
                default: return 'assets/sprites/items/mystery.png';
            }
        }
        
        // Get slot machine sprite based on slot type
        function getSlotSprite(slotType) {
            switch(slotType) {
                case 'gold': return 'assets/sprites/items/slots/gold.png';
                case 'score': return 'assets/sprites/items/slots/score.png';
                case 'random': return 'assets/sprites/items/slots/random.png';
                default: return 'assets/sprites/items/slots/random.png';
            }
        }
        
        // Achievements and character unlock system
        const achievements = {
            pawn: { unlocked: true, name: "Pawn Starter", description: "Start with the pawn", condition: "default" },
            knight: { unlocked: false, name: "Knight's Quest", description: "Reach level 10", condition: "level", value: 10 },
            bishop: { unlocked: false, name: "Holy Bishop", description: "Complete level 15", condition: "level", value: 15 },
            rook: { unlocked: false, name: "Castle Crasher", description: "Promote 5 pawns", condition: "promotion", value: 5 },
            queen: { unlocked: false, name: "Royalty", description: "Complete level 25", condition: "level", value: 25 },
            king: { unlocked: false, name: "Checkmate", description: "Promote 3 pawns", condition: "promotion", value: 3 },
            // Дополнительные сложные достижения
            grandmaster: { unlocked: false, name: "Grandmaster", description: "Reach level 50", condition: "level", value: 50 },
            collector: { unlocked: false, name: "Master Collector", description: "Collect 100 items", condition: "items", value: 100 },
            slayer: { unlocked: false, name: "Enemy Slayer", description: "Defeat 200 enemies", condition: "kills", value: 200 },
            promoter: { unlocked: false, name: "Pawn Promoter", description: "Promote 10 pawns", condition: "promotion", value: 10 }
        };

        // Load achievements from localStorage
        function loadAchievements() {
            const saved = localStorage.getItem('chessRogueAchievements');
            if (saved) {
                const savedAchievements = JSON.parse(saved);
                Object.keys(savedAchievements).forEach(key => {
                    if (achievements[key]) {
                        achievements[key].unlocked = savedAchievements[key].unlocked;
                    }
                });
            }
        }

        // Save achievements to localStorage
        function saveAchievements() {
            localStorage.setItem('chessRogueAchievements', JSON.stringify(achievements));
        }
        
        // Проверить, активен ли эффект
        function isEffectActive(effectId) {
            return gameState.effects.temporary.includes(effectId);
        }
        
        // Применить постоянный эффект
        function applyPermanentEffect(effectId) {
            const effect = permanentEffects.find(e => e.id === effectId);
            if (effect) {
                effect.apply();
                gameState.effects.permanent.push(effectId);
                addMessage(`Applied permanent effect: ${effect.name}`);
            }
        }
        
        // Применить временный эффект
        function applyTemporaryEffect(effectId) {
            const effect = temporaryEffects.find(e => e.id === effectId);
            if (effect) {
                effect.apply();
                gameState.effects.temporary.push(effectId);
                addMessage(`Applied temporary effect: ${effect.name}`);
            }
        }
        
        // Применить разовый эффект
        function applyOneTimeEffect(effectId) {
            const effect = oneTimeEffects.find(e => e.id === effectId);
            if (effect) {
                effect.apply();
                gameState.effects.oneTime.push(effectId);
                addMessage(`Applied one-time effect: ${effect.name}`);
            }
        }
        
        // Очистить временные эффекты (вызывается при завершении уровня)
        function clearTemporaryEffects() {
            gameState.effects.temporary = [];
            addMessage("Temporary effects cleared!");
        }
        
        // Check and unlock achievements
        function checkAndUnlockAchievements() {
            let unlocked = false;
            
            // Knight - Reach level 10
            if (!achievements.knight.unlocked && gameState.currentLevel >= 10) {
                achievements.knight.unlocked = true;
                addMessage("Achievement Unlocked: Knight's Quest!");
                unlocked = true;
            }
            
            // Bishop - Complete level 15
            if (!achievements.bishop.unlocked && gameState.currentLevel >= 15) {
                achievements.bishop.unlocked = true;
                addMessage("Achievement Unlocked: Holy Bishop!");
                unlocked = true;
            }
            
            // Rook - Promote 5 pawns
            if (!achievements.rook.unlocked) {
                const promotedPawns = gameState.player.pieces.filter(p => p.type === 'queen' || p.type === 'rook' || p.type === 'bishop' || p.type === 'knight').length;
                if (promotedPawns >= 5) {
                achievements.rook.unlocked = true;
                addMessage("Achievement Unlocked: Castle Crasher!");
                unlocked = true;
            }
            }
            
            // Queen - Complete level 25
            if (!achievements.queen.unlocked && gameState.currentLevel >= 25) {
                    achievements.queen.unlocked = true;
                    addMessage("Achievement Unlocked: Royalty!");
                    unlocked = true;
                }
            
            // King - Promote 3 pawns
            if (!achievements.king.unlocked) {
                const promotedPawns = gameState.player.pieces.filter(p => p.type === 'queen' || p.type === 'rook' || p.type === 'bishop' || p.type === 'knight').length;
                if (promotedPawns >= 3) {
                achievements.king.unlocked = true;
                addMessage("Achievement Unlocked: Checkmate!");
                unlocked = true;
                }
            }
            
            // Дополнительные сложные достижения
            // Grandmaster - Reach level 50
            if (!achievements.grandmaster.unlocked && gameState.currentLevel >= 50) {
                achievements.grandmaster.unlocked = true;
                addMessage("Achievement Unlocked: Grandmaster!");
                unlocked = true;
            }
            
            // Master Collector - Collect 100 items
            if (!achievements.collector.unlocked && gameState.player.inventory.length >= 100) {
                achievements.collector.unlocked = true;
                addMessage("Achievement Unlocked: Master Collector!");
                unlocked = true;
            }
            
            // Enemy Slayer - Defeat 200 enemies
            if (!achievements.slayer.unlocked && gameState.player.kills >= 200) {
                achievements.slayer.unlocked = true;
                addMessage("Achievement Unlocked: Enemy Slayer!");
                unlocked = true;
            }
            
            // Pawn Promoter - Promote 10 pawns
            if (!achievements.promoter.unlocked) {
                const promotedPawns = gameState.player.pieces.filter(p => p.type === 'queen' || p.type === 'rook' || p.type === 'bishop' || p.type === 'knight').length;
                if (promotedPawns >= 10) {
                    achievements.promoter.unlocked = true;
                    addMessage("Achievement Unlocked: Pawn Promoter!");
                    unlocked = true;
                }
            }
            
            if (unlocked) {
                saveAchievements();
                // Update character select screen if it's visible
                updateCharacterSelect();
                // Update progress indicator
                updateProgressIndicator();
                // Show unlock notification
                showUnlockNotification();
            }
        }

        // Game state
        const gameState = {
            currentLevel: 1,
            score: 0,
            player: {
                pieces: [
                    { type: 'pawn', x: 0, y: 0, alive: true, isActive: true } // Первая фигура
                ],
                activePieceIndex: 0, // Индекс активной фигуры
                gold: 0,
                inventory: [],
                abilities: [],
                kills: 0
            },
            board: [],
            boardSize: 8,
            enemies: [],
            items: [],
            exit: { x: 0, y: 0 },
            messages: [],
            currentTurn: 'player', // 'player' или 'enemy'
            // Система эффектов
            effects: {
                temporary: [], // Временные эффекты (действуют 1 уровень)
                permanent: [], // Постоянные эффекты (действуют весь забег)
                oneTime: [] // Разовые эффекты (отображаются в интерфейсе)
            },
            topWalls: [],
            bottomWalls: []
        };
        
        // Переменная для хранения выбранного персонажа
        let selectedCharacter = 'pawn';
        
        // Piece movement patterns
        const movementPatterns = {
            pawn: [
                { x: 0, y: 1 },  // Down
                { x: 0, y: -1 }, // Up 
                { x: 1, y: 0 },  // Right
                { x: -1, y: 0 }  // Left
            ],
            knight: [
                { x: 1, y: 2 }, { x: 2, y: 1 },
                { x: 2, y: -1 }, { x: 1, y: -2 },
                { x: -1, y: -2 }, { x: -2, y: -1 },
                { x: -2, y: 1 }, { x: -1, y: 2 }
            ],
            bishop: [],
            rook: [],
            queen: [],
            king: [
                { x: 0, y: 1 }, { x: 1, y: 1 },
                { x: 1, y: 0 }, { x: 1, y: -1 },
                { x: 0, y: -1 }, { x: -1, y: -1 },
                { x: -1, y: 0 }, { x: -1, y: 1 }
            ]
        };
        
        // Initialize bishop, rook and queen patterns
        for (let i = 1; i < 8; i++) {
            movementPatterns.bishop.push(
                { x: i, y: i }, { x: i, y: -i },
                { x: -i, y: i }, { x: -i, y: -i }
            );
            
            movementPatterns.rook.push(
                { x: 0, y: i }, { x: i, y: 0 },
                { x: 0, y: -i }, { x: -i, y: 0 }
            );
            
            movementPatterns.queen.push(
                { x: 0, y: i }, { x: i, y: 0 },
                { x: 0, y: -i }, { x: -i, y: 0 },
                { x: i, y: i }, { x: i, y: -i },
                { x: -i, y: i }, { x: -i, y: -i }
            );
        }
        
        // Enemy types (теперь без здоровья и атаки)
        const enemyTypes = [
            { name: 'Pawn', piece: 'pawn', symbol: '♟', color: 'red' },
            { name: 'Knight', piece: 'knight', symbol: '♞', color: 'red' },
            { name: 'Bishop', piece: 'bishop', symbol: '♝', color: 'red' },
            { name: 'Rook', piece: 'rook', symbol: '♜', color: 'red' },
            { name: 'Queen', piece: 'queen', symbol: '♛', color: 'red' }
        ];
        
        // Item types (теперь только фигуры с разной редкостью)
        const itemTypes = [
            { name: 'Pawn', effect: 'piece', value: 'pawn', symbol: '♙', color: 'green', rarity: 0.4 }, // 40% - самая частая
            { name: 'Knight', effect: 'piece', value: 'knight', symbol: '♘', color: 'green', rarity: 0.25 }, // 25%
            { name: 'Bishop', effect: 'piece', value: 'bishop', symbol: '♗', color: 'green', rarity: 0.2 }, // 20%
            { name: 'Rook', effect: 'piece', value: 'rook', symbol: '♖', color: 'green', rarity: 0.1 }, // 10%
            { name: 'Queen', effect: 'piece', value: 'queen', symbol: '♕', color: 'green', rarity: 0.05 } // 5% - самая редкая
        ];
        
        // Bonus items (золото и другие бонусы)
        const bonusItems = [
            { name: 'Gold Coin', effect: 'gold', value: 5, symbol: 'gold', color: 'gold', rarity: 0.3 }
        ];
        
        // Универсальный объект "звезда" - дает случайный эффект
        const starItem = {
            name: 'Mystery Star',
            effect: 'random_effect',
            symbol: 'mystery',
            color: 'yellow',
            rarity: 0.2
        };
        
        // Новые объекты на доске
        const specialItems = [
            {
                name: 'Diamond',
                effect: 'gold',
                value: 15,
                symbol: 'gold',
                color: 'cyan',
                rarity: 0.05
            },
            {
                name: 'Treasure Chest',
                effect: 'random_effect',
                symbol: 'chest',
                color: 'brown',
                rarity: 0.08
            },
            {
                name: 'Slot Machine',
                effect: 'random_effect',
                symbol: 'slot',
                color: 'purple',
                rarity: 0.03
            }
        ];
        
        // Временные эффекты (действуют 1 уровень)
        const temporaryEffects = [
            { 
                id: 'all_pawns', 
                name: 'Pawn Chaos', 
                description: 'All pieces become pawns for this level',
                symbol: '♙♙♙', 
                color: 'orange',
                rarity: 0.1,
                type: 'positive',
                apply: () => {
                    // Все фигуры игрока становятся пешками
                    gameState.player.pieces.forEach(piece => {
                        if (piece.alive) piece.type = 'pawn';
                    });
                    // Все враги становятся пешками
                    gameState.enemies.forEach(enemy => {
                        enemy.piece = 'pawn';
                        enemy.symbol = '♟';
                    });
                    addMessage("All pieces became pawns!");
                }
            },
            { 
                id: 'all_queens', 
                name: 'Queen Power', 
                description: 'All pieces become queens for this level',
                symbol: '♕♕♕', 
                color: 'purple',
                rarity: 0.05,
                type: 'positive',
                apply: () => {
                    // Все фигуры игрока становятся ферзями
                    gameState.player.pieces.forEach(piece => {
                        if (piece.alive) piece.type = 'queen';
                    });
                    // Все враги становятся ферзями
                    gameState.enemies.forEach(enemy => {
                        enemy.piece = 'queen';
                        enemy.symbol = '♛';
                    });
                    addMessage("All pieces became queens!");
                }
            },
            { 
                id: 'enemy_pawns', 
                name: 'Enemy Weakening', 
                description: 'All enemies become pawns for this level',
                symbol: '♟♟♟', 
                color: 'green',
                rarity: 0.15,
                type: 'positive',
                apply: () => {
                    // Все враги становятся пешками
                    gameState.enemies.forEach(enemy => {
                        enemy.piece = 'pawn';
                        enemy.symbol = '♟';
                    });
                    addMessage("All enemies became pawns!");
                }
            },
            { 
                id: 'ai_disabled', 
                name: 'AI Disabled', 
                description: 'Enemies will not move for this level',
                symbol: '🤖❌', 
                color: 'red',
                rarity: 0.08,
                type: 'positive',
                apply: () => {
                    addMessage("AI is disabled - enemies won't move!");
                }
            },
            { 
                id: 'master_key', 
                name: 'Master Key', 
                description: 'Exit is available without defeating all enemies',
                symbol: '🗝️', 
                color: 'gold',
                rarity: 0.12,
                type: 'positive',
                apply: () => {
                    addMessage("Master Key activated - exit is now available!");
                }
            },
            // Негативные эффекты
            { 
                id: 'player_pawns', 
                name: 'Player Weakening', 
                description: 'All your pieces become pawns for this level',
                symbol: '♙♙♙', 
                color: 'red',
                rarity: 0.1,
                type: 'negative',
                apply: () => {
                    // Все фигуры игрока становятся пешками
                    gameState.player.pieces.forEach(piece => {
                        if (piece.alive) piece.type = 'pawn';
                    });
                    addMessage("All your pieces became pawns!");
                }
            },
            { 
                id: 'enemy_queens', 
                name: 'Enemy Power', 
                description: 'All enemies become queens for this level',
                symbol: '♛♛♛', 
                color: 'darkred',
                rarity: 0.05,
                type: 'negative',
                apply: () => {
                    // Все враги становятся ферзями
                    gameState.enemies.forEach(enemy => {
                        enemy.piece = 'queen';
                        enemy.symbol = '♛';
                    });
                    addMessage("All enemies became queens!");
                }
            },
            { 
                id: 'chaos_mode', 
                name: 'Chaos Mode', 
                description: 'All pieces are randomly shuffled',
                symbol: '🌀', 
                color: 'purple',
                rarity: 0.08,
                type: 'negative',
                apply: () => {
                    // Перемешиваем все фигуры игрока
                    const alivePieces = gameState.player.pieces.filter(p => p.alive);
                    const positions = alivePieces.map(p => ({ x: p.x, y: p.y }));
                    
                    // Перемешиваем позиции
                    for (let i = positions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [positions[i], positions[j]] = [positions[j], positions[i]];
                    }
                    
                    // Применяем новые позиции
                    alivePieces.forEach((piece, index) => {
                        piece.x = positions[index].x;
                        piece.y = positions[index].y;
                    });
                    
                    addMessage("Chaos mode activated - pieces shuffled!");
                }
            },
            { 
                id: 'double_ai', 
                name: 'Double AI', 
                description: 'Enemies move twice per turn',
                symbol: '🤖🤖', 
                color: 'darkred',
                rarity: 0.06,
                type: 'negative',
                apply: () => {
                    addMessage("Double AI activated - enemies move twice!");
                }
            }
        ];
        
        // Постоянные эффекты (действуют весь забег до проигрыша)
        const permanentEffects = [
            { 
                id: 'gold_boost', 
                name: 'Gold Magnet', 
                description: 'Increase gold gain by 10%',
                symbol: '💰', 
                color: 'gold',
                rarity: 0.15,
                type: 'positive',
                value: 0.1, // 10% бонус
                apply: () => {
                    addMessage("Gold Magnet activated - you'll get more gold!");
                }
            },
            { 
                id: 'score_boost', 
                name: 'Score Multiplier', 
                description: 'Increase score gain by 10%',
                symbol: '📈', 
                color: 'green',
                rarity: 0.12,
                type: 'positive',
                value: 0.1, // 10% бонус
                apply: () => {
                    addMessage("Score Multiplier activated - you'll get more points!");
                }
            },
            { 
                id: 'shop_discount', 
                name: 'Shop Discount', 
                description: 'Reduce shop prices by 5%',
                symbol: '🏪', 
                color: 'blue',
                rarity: 0.1,
                type: 'positive',
                value: 0.05, // 5% скидка
                apply: () => {
                    addMessage("Shop Discount activated - items will be cheaper!");
                }
            },
            { 
                id: 'shop_markup', 
                name: 'Shop Markup', 
                description: 'Increase shop prices by 5%',
                symbol: '💸', 
                color: 'red',
                rarity: 0.08,
                type: 'negative',
                value: 0.05, // 5% надбавка
                apply: () => {
                    addMessage("Shop Markup activated - items will be more expensive!");
                }
            }
        ];
        
        // Разовые эффекты (применяются один раз при подборе)
        const oneTimeEffects = [
            { 
                id: 'add_pawn', 
                name: 'Pawn Summon', 
                description: 'Add a pawn to your collection',
                symbol: '♙+', 
                color: 'green',
                rarity: 0.2,
                type: 'positive',
                apply: () => {
                    // Ищем свободную позицию для новой пешки
                    let newX, newY;
                    let attempts = 0;
                    let isOccupied;
                    do {
                        newX = Math.floor(Math.random() * gameState.boardSize);
                        newY = Math.floor(Math.random() * gameState.boardSize);
                        attempts++;
                        
                        isOccupied = gameState.enemies.some(e => e.x === newX && e.y === newY) ||
                                          gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY) ||
                                          gameState.items.some(item => item.x === newX && item.y === newY) ||
                                          (newX === gameState.exit.x && newY === gameState.exit.y);
                    } while (isOccupied && attempts < 50);
                    
                    if (attempts < 50) {
                        gameState.player.pieces.push({ 
                            type: 'pawn', 
                            x: newX, 
                            y: newY, 
                            alive: true, 
                            isActive: false 
                        });
                        addMessage("A new pawn joined your army!");
                    } else {
                        addMessage("No space for new pawn - converted to gold!");
                        gameState.player.gold += 10;
                    }
                }
            },
            { 
                id: 'add_gold', 
                name: 'Gold Rush', 
                description: 'Gain 20 gold immediately',
                symbol: '💰+', 
                color: 'gold',
                rarity: 0.15,
                type: 'positive',
                apply: () => {
                    gameState.player.gold += 20;
                    addMessage("Gold Rush! +20 gold!");
                }
            },
            { 
                id: 'add_score', 
                name: 'Score Boost', 
                description: 'Gain 100 points immediately',
                symbol: '📈+', 
                color: 'blue',
                rarity: 0.12,
                type: 'positive',
                apply: () => {
                    gameState.score += 100;
                    addMessage("Score Boost! +100 points!");
                }
            },
            { 
                id: 'level_skip', 
                name: 'Level Skip', 
                description: 'Skip to next level immediately',
                symbol: '⏭️', 
                color: 'purple',
                rarity: 0.05,
                type: 'positive',
                apply: () => {
                    addMessage("Level Skip activated! Moving to next level...");
                    setTimeout(() => {
                        completeLevel();
                    }, 1000);
                }
            },
            { 
                id: 'random_piece', 
                name: 'Random Piece', 
                description: 'Add a random piece to your collection',
                symbol: '🎲', 
                color: 'orange',
                rarity: 0.1,
                type: 'positive',
                apply: () => {
                    const pieceTypes = ['pawn', 'knight', 'bishop', 'rook', 'queen'];
                    const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
                    
                    // Ищем свободную позицию
                    let newX, newY;
                    let attempts = 0;
                    let isOccupied;
                    do {
                        newX = Math.floor(Math.random() * gameState.boardSize);
                        newY = Math.floor(Math.random() * gameState.boardSize);
                        attempts++;
                        
                        isOccupied = gameState.enemies.some(e => e.x === newX && e.y === newY) ||
                                          gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY) ||
                                          gameState.items.some(item => item.x === newX && item.y === newY) ||
                                          (newX === gameState.exit.x && newY === gameState.exit.y);
                    } while (isOccupied && attempts < 50);
                    
                    if (attempts < 50) {
                        gameState.player.pieces.push({ 
                            type: randomType, 
                            x: newX, 
                            y: newY, 
                            alive: true, 
                            isActive: false 
                        });
                        addMessage(`Random piece summoned: ${randomType}!`);
                    } else {
                        addMessage("No space for new piece - converted to gold!");
                        gameState.player.gold += 15;
                    }
                }
            }
        ];
        
        // Рекламные функции для MyTarget
        let adManager = {
            interstitialReady: false,
            rewardedReady: false,
            adShownCount: 0,
            lastAdTime: 0,
            initialized: false
        };
        
        // Инициализация рекламы
        function initializeAds() {
            console.log('=== ИНИЦИАЛИЗАЦИЯ РЕКЛАМЫ ===');
            console.log('Capacitor global:', typeof Capacitor !== 'undefined');
            console.log('window.Capacitor:', !!window.Capacitor);
            
            if (window.Capacitor) {
                console.log('Capacitor plugins:', Object.keys(window.Capacitor.Plugins || {}));
                console.log('MyTargetPlugin in window.Capacitor:', !!window.Capacitor.Plugins?.MyTargetPlugin);
                console.log('TestPlugin in window.Capacitor:', !!window.Capacitor.Plugins?.TestPlugin);
            }
            
            // Проверяем доступность Cordova плагина
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                console.log('Cordova AdPlugin доступен');
                initializeMyTarget();
            } else {
                console.log('Cordova AdPlugin недоступен - запуск в браузере');
                console.log('window.cordova:', !!window.cordova);
                console.log('window.cordova.plugins:', !!window.cordova?.plugins);
                console.log('window.cordova.plugins.adPlugin:', !!window.cordova?.plugins?.adPlugin);
            }
            
            // Альтернативный способ - через deviceready
            document.addEventListener('deviceready', function() {
                console.log('=== DEVICEREADY СОБЫТИЕ ===');
                console.log('Capacitor global:', typeof Capacitor !== 'undefined');
                console.log('window.Capacitor:', !!window.Capacitor);
                
                if (window.Capacitor) {
                    console.log('Capacitor plugins:', Object.keys(window.Capacitor.Plugins || {}));
                    console.log('MyTargetPlugin in window.Capacitor:', !!window.Capacitor.Plugins?.MyTargetPlugin);
                }
                
                if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                    console.log('Cordova AdPlugin найден через deviceready');
                    initializeMyTarget();
                }
            }, false);
        }
        
        // Инициализация MyTarget
        function initializeMyTarget() {
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                window.cordova.plugins.adPlugin.initialize("1814479")
                    .then(() => {
                        console.log('MyTarget initialized successfully');
                        adManager.initialized = true;
                        checkAdStatus();
                    })
                    .catch(err => {
                        console.error('MyTarget initialization failed:', err);
                    });
            }
        }
        
        // Проверка статуса рекламы
        function checkAdStatus() {
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                // Используем глобальные флаги вместо методов
                adManager.interstitialReady = window.adIsLoaded || false;
                adManager.rewardedReady = window.adIsLoaded || false;
                console.log('Interstitial ready:', adManager.interstitialReady);
                console.log('Rewarded ready:', adManager.rewardedReady);
            }
        }
        
        // Показать межстраничную рекламу
        function showInterstitialAd() {
            const now = Date.now();
            const timeSinceLastAd = now - adManager.lastAdTime;
            
            // Показываем рекламу не чаще чем раз в 30 секунд
            if (timeSinceLastAd < 30000) {
                console.log('Слишком рано для показа рекламы');
                return;
            }
            
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                window.cordova.plugins.adPlugin.showInterstitialAd()
                    .then(() => {
                        console.log('Interstitial ad shown');
                        adManager.adShownCount++;
                        adManager.lastAdTime = now;
                        // Перепроверяем статус рекламы после показа
                        setTimeout(checkAdStatus, 1000);
                    })
                    .catch(err => {
                        console.log('Interstitial ad error:', err);
                        // Перезагружаем рекламу при ошибке
                        window.cordova.plugins.adPlugin.loadInterstitialAd()
                            .then(() => {
                                console.log('Interstitial ad reloaded');
                                setTimeout(checkAdStatus, 1000);
                            })
                            .catch(reloadErr => console.log('Interstitial reload error:', reloadErr));
                    });
            }
        }
        
        // Показать rewarded рекламу
        function showRewardedAd() {
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                window.cordova.plugins.adPlugin.showRewardedAd()
                    .then(() => {
                        console.log('Rewarded ad shown');
                        adManager.adShownCount++;
                        adManager.lastAdTime = Date.now();
                        // Даем награду игроку
                        giveRewardForAd();
                        // Перепроверяем статус рекламы после показа
                        setTimeout(checkAdStatus, 1000);
                    })
                    .catch(err => {
                        console.log('Rewarded ad error:', err);
                        // Перезагружаем рекламу при ошибке
                        window.cordova.plugins.adPlugin.loadRewardedAd(1814482)
                            .then(() => {
                                console.log('Rewarded ad reloaded');
                                setTimeout(checkAdStatus, 1000);
                            })
                            .catch(reloadErr => console.log('Rewarded reload error:', reloadErr));
                    });
            }
        }
        
        // Награда за просмотр рекламы
        function giveRewardForAd() {
            const rewards = [
                { type: 'gold', amount: 50, message: 'Реклама просмотрена! +50 золота!' },
                { type: 'score', amount: 200, message: 'Реклама просмотрена! +200 очков!' },
                { type: 'health', amount: 1, message: 'Реклама просмотрена! +1 здоровье!' }
            ];
            
            const reward = rewards[Math.floor(Math.random() * rewards.length)];
            
            switch(reward.type) {
                case 'gold':
                    gameState.player.gold += reward.amount;
                    break;
                case 'score':
                    gameState.score += reward.amount;
                    break;
                case 'health':
                    // Восстанавливаем здоровье активной фигуры
                    const activePiece = gameState.player.pieces[gameState.player.activePieceIndex];
                    if (activePiece && activePiece.health < activePiece.maxHealth) {
                        activePiece.health = Math.min(activePiece.health + reward.amount, activePiece.maxHealth);
                    }
                    break;
            }
            
            addMessage(reward.message);
            updateUI();
        }
        
        // Показать рекламу при завершении уровня
        function showAdOnLevelComplete() {
            if (adManager.interstitialReady) {
                showInterstitialAd();
            }
        }
        
        // Показать рекламу при смерти игрока
        function showAdOnGameOver() {
            if (adManager.interstitialReady) {
                showInterstitialAd();
            }
        }
        
        // Добавить кнопку для rewarded рекламы в UI
        function addRewardedAdButton() {
            const uiContainer = document.getElementById('ui-container');
            if (!uiContainer) return;
            
            // Проверяем, есть ли уже кнопка
            if (document.getElementById('rewarded-ad-btn')) return;
            
            const adButton = document.createElement('button');
            adButton.id = 'rewarded-ad-btn';
            adButton.className = 'pixel-button';
            adButton.innerHTML = '🎁 Реклама';
            adButton.style.position = 'absolute';
            adButton.style.top = '10px';
            adButton.style.right = '10px';
            adButton.style.zIndex = '1000';
            adButton.style.fontSize = '8px';
            adButton.style.padding = '6px 10px';
            
            adButton.addEventListener('click', () => {
                if (adManager.rewardedReady) {
                    showRewardedAd();
                } else {
                    addMessage('Реклама загружается...');
                    // Загружаем rewarded рекламу
                    if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                        window.cordova.plugins.adPlugin.loadRewardedAd(1814482)
                            .then(() => {
                                console.log('Rewarded ad loaded');
                                checkAdStatus();
                            })
                            .catch(err => {
                                console.log('Rewarded ad load error:', err);
                                addMessage('Ошибка загрузки рекламы');
                            });
                    }
                }
            });
            
            uiContainer.appendChild(adButton);
        }
        
        // Initialize the game
        function initGame() {
            // Load achievements from localStorage
            loadAchievements();
            
            // Инициализируем рекламу
            initializeAds();
            
            // Create floating pieces for main menu
            createFloatingPieces(document.getElementById('main-menu'));
            
            // Show main menu
            document.getElementById('main-menu').classList.add('flex');
            document.getElementById('main-menu').classList.remove('hidden');
            
            // Set up event listeners
            setupEventListeners();
        }
        
        // Create animated floating pieces for main menu background
        function createFloatingPieces(container) {
            if (!container) return;
            
            const pieces = [
                { type: 'king', color: 'white', top: '10%', left: '5%' },
                { type: 'queen', color: 'black', top: '15%', right: '8%' },
                { type: 'rook', color: 'white', top: '25%', left: '15%' },
                { type: 'bishop', color: 'black', top: '30%', right: '20%' },
                { type: 'knight', color: 'white', top: '45%', left: '8%' },
                { type: 'pawn', color: 'black', top: '50%', right: '12%' },
                { type: 'bishop', color: 'white', top: '65%', left: '25%' },
                { type: 'knight', color: 'black', top: '70%', right: '5%' },
                { type: 'queen', color: 'white', top: '80%', left: '10%' },
                { type: 'king', color: 'black', top: '85%', right: '18%' },
                { type: 'pawn', color: 'white', top: '90%', left: '30%' },
                { type: 'rook', color: 'black', top: '95%', right: '30%' }
            ];
            
            pieces.forEach(piece => {
                const pieceElement = document.createElement('div');
                pieceElement.className = `floating-piece ${piece.color} ${piece.type}`;
                pieceElement.style.top = piece.top;
                if (piece.left) pieceElement.style.left = piece.left;
                if (piece.right) pieceElement.style.right = piece.right;
                
                const imgElement = document.createElement('img');
                imgElement.src = `assets/sprites/figures/${piece.color}/${piece.type}.png`;
                imgElement.alt = `${piece.color} ${piece.type}`;
                imgElement.style.width = '100%';
                imgElement.style.height = '100%';
                imgElement.style.objectFit = 'contain';
                
                pieceElement.appendChild(imgElement);
                container.appendChild(pieceElement);
            });
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Main menu buttons
            document.getElementById('start-game').addEventListener('click', () => {
                document.getElementById('main-menu').classList.remove('flex');
                generateCharacterSelect(); // Generate the character select screen
                document.getElementById('character-select').classList.add('flex');
                // Create floating pieces for character select
                createFloatingPieces(document.getElementById('character-select'));
                showInterstitialAd();
            });
            
            document.getElementById('how-to-play').addEventListener('click', () => {
                document.getElementById('main-menu').classList.remove('flex');
                document.getElementById('how-to-play-modal').classList.add('flex');
                // Create floating pieces for how to play
                createFloatingPieces(document.getElementById('how-to-play-modal'));
                showInterstitialAd();
            });
            
            document.getElementById('credits').addEventListener('click', () => {
                document.getElementById('main-menu').classList.remove('flex');
                document.getElementById('credits-modal').classList.add('flex');
                // Create floating pieces for credits
                createFloatingPieces(document.getElementById('credits-modal'));
                showInterstitialAd();
            });
            
            // Reset achievements button
            document.getElementById('reset-achievements').addEventListener('click', () => {
                if (confirm('Are you sure you want to reset all achievements? This will lock all characters except Pawn.')) {
                    resetAchievements();
                    alert('Achievements reset! All characters except Pawn are now locked.');
                }
            });
            
            // Character select
            document.getElementById('back-to-menu').addEventListener('click', () => {
                clearFloatingPieces(document.getElementById('character-select'));
                document.getElementById('character-select').classList.remove('flex');
                document.getElementById('main-menu').classList.add('flex');
            });
            
            // Character preview
            document.getElementById('preview-back').addEventListener('click', () => {
                clearFloatingPieces(document.getElementById('character-preview'));
                hideCharacterPreview();
            });
            
            document.getElementById('preview-start').addEventListener('click', () => {
                const selectedCharacter = document.getElementById('preview-start').dataset.character;
                if (selectedCharacter && achievements[selectedCharacter].unlocked) {
                    clearFloatingPieces(document.getElementById('character-preview'));
                    startGame(selectedCharacter);
                }
            });
            
            // How to play
            document.getElementById('close-how-to-play').addEventListener('click', () => {
                clearFloatingPieces(document.getElementById('how-to-play-modal'));
                document.getElementById('how-to-play-modal').classList.remove('flex');
                document.getElementById('main-menu').classList.add('flex');
            });
            
            // Credits
            document.getElementById('close-credits').addEventListener('click', () => {
                clearFloatingPieces(document.getElementById('credits-modal'));
                document.getElementById('credits-modal').classList.remove('flex');
                document.getElementById('main-menu').classList.add('flex');
            });
            
            // Game over
            document.getElementById('restart-game').addEventListener('click', restartGame);
            document.getElementById('game-over-to-menu').addEventListener('click', () => {
                document.getElementById('game-over-modal').classList.remove('flex');
                document.getElementById('main-menu').classList.add('flex');
                document.getElementById('game-container').classList.add('hidden');
            });
            
            // Level complete
            document.getElementById('next-level').addEventListener('click', () => {
                document.getElementById('level-complete-modal').classList.remove('flex');
                gameState.currentLevel++;
                generateLevel();
            });
            
            // Shop
            document.getElementById('shop-skip').addEventListener('click', () => {
                document.getElementById('shop-modal').classList.remove('flex');
                gameState.currentLevel++;
                generateLevel();
            });
            
            document.getElementById('shop-continue').addEventListener('click', () => {
                document.getElementById('shop-modal').classList.remove('flex');
                gameState.currentLevel++;
                generateLevel();
            });
            
            // In-game menu
            document.getElementById('open-menu').addEventListener('click', () => {
                document.getElementById('in-game-menu').classList.remove('hidden');
                document.getElementById('in-game-menu').classList.add('flex');
            });
            
            document.getElementById('resume-game').addEventListener('click', () => {
                document.getElementById('in-game-menu').classList.add('hidden');
                document.getElementById('in-game-menu').classList.remove('flex');
            });
            
            document.getElementById('concede-game').addEventListener('click', () => {
                if (confirm('Are you sure you want to concede? This will end your current game.')) {
                    // Закрываем game menu
                    document.getElementById('in-game-menu').classList.add('hidden');
                    document.getElementById('in-game-menu').classList.remove('flex');
                    
                    // Показываем game over
                    gameOver();
                }
            });
            
            document.getElementById('return-to-menu').addEventListener('click', () => {
                if (confirm('Are you sure you want to return to the main menu? Your current progress will be lost.')) {
                document.getElementById('in-game-menu').classList.add('hidden');
                    document.getElementById('in-game-menu').classList.remove('flex');
                document.getElementById('game-container').classList.add('hidden');
                document.getElementById('main-menu').classList.add('flex');
                }
            });
            
            // Keyboard controls
            document.addEventListener('keydown', handleKeyPress);
        }
        
        // Start the game
        function startGame(selectedPiece) {
            if (!selectedPiece) selectedPiece = 'pawn';
            
            // Сохраняем выбранного персонажа
            selectedCharacter = selectedPiece;
            
            gameState.player.pieces[0].type = selectedPiece;
            // Reset game state
            gameState.currentLevel = 1;
            gameState.score = 0;
            gameState.player.gold = 0;
            gameState.player.inventory = [];
            gameState.player.abilities = [];
            gameState.player.kills = 0;
            gameState.messages = [];
            // Сбрасываем эффекты
            gameState.effects.temporary = [];
            gameState.effects.permanent = [];
            gameState.effects.oneTime = [];
            // Hide character select and show game
            document.getElementById('character-select').classList.remove('flex');
            document.getElementById('character-preview').style.display = 'none';
            document.getElementById('game-container').classList.remove('hidden');
            
            // Добавляем кнопку rewarded рекламы
            addRewardedAdButton();
            
            // Generate first level
            generateLevel();
        }
        
        // Reset achievements (for testing)
        function resetAchievements() {
            Object.keys(achievements).forEach(key => {
                if (key !== 'pawn') {
                    achievements[key].unlocked = false;
                }
            });
            saveAchievements();
            updateCharacterSelect();
        }
        
        // Restart the game
        function restartGame() {
            document.getElementById('game-over-modal').classList.remove('flex');
            document.getElementById('level-complete-modal').classList.remove('flex');
            document.getElementById('in-game-menu').classList.add('hidden');
            document.getElementById('in-game-menu').classList.remove('flex');
            
            // Полностью сбрасываем состояние игры
            gameState.currentLevel = 1;
            gameState.score = 0;
            gameState.player.gold = 0;
            gameState.player.inventory = [];
            gameState.player.abilities = [];
            gameState.player.kills = 0;
            gameState.messages = [];
            // Сбрасываем эффекты
            gameState.effects.temporary = [];
            gameState.effects.permanent = [];
            gameState.effects.oneTime = [];
            
            // Сбрасываем фигуры игрока к начальному состоянию с сохранённым персонажем
            gameState.player.pieces = [
                { type: selectedCharacter, x: 0, y: 0, alive: true, isActive: true }
            ];
            gameState.player.activePieceIndex = 0;
            
            // Генерируем первый уровень
            generateLevel();
        }
        
        // Generate a new level
        function generateLevel() {
            // Генерируем стены для уровня
            gameState.topWalls = Array.from({length: gameState.boardSize}, () => getRandomWallSprite());
            gameState.bottomWalls = Array.from({length: gameState.boardSize}, () => getRandomWallSprite());
            // Clear the board
            gameState.board = [];
            gameState.enemies = [];
            gameState.items = [];
            
            // Create empty board
            for (let y = 0; y < gameState.boardSize; y++) {
                gameState.board[y] = [];
                for (let x = 0; x < gameState.boardSize; x++) {
                    gameState.board[y][x] = { x, y, type: 'empty' };
                }
            }
            
            // Размещаем все живые фигуры игрока на случайных позициях
            gameState.player.pieces.forEach((piece, index) => {
                let x, y;
                let attempts = 0;
                let isOccupied;
                
                do {
                    x = Math.floor(Math.random() * gameState.boardSize);
                    y = Math.floor(Math.random() * gameState.boardSize);
                    attempts++;
                    
                    // Проверяем, что клетка свободна от других фигур игрока
                    isOccupied = gameState.player.pieces.some((otherPiece, otherIndex) => 
                        otherIndex < index && otherPiece.alive && otherPiece.x === x && otherPiece.y === y
                    );
                } while (isOccupied && attempts < 50);
                
                // Если не нашли свободную клетку после 50 попыток, размещаем в случайном месте
                if (attempts >= 50) {
                    x = Math.floor(Math.random() * gameState.boardSize);
                    y = Math.floor(Math.random() * gameState.boardSize);
                }
                
                piece.x = x;
                piece.y = y;
                piece.alive = true;
            });
            
            // Place exit at opposite side from first player piece
            const firstPiece = gameState.player.pieces[0];
            gameState.exit = {
                x: Math.abs(firstPiece.x - (gameState.boardSize - 1)),
                y: Math.abs(firstPiece.y - (gameState.boardSize - 1))
            };
            
            // Generate enemies (more enemies as level increases)
            const numEnemies = Math.min(3 + Math.floor(gameState.currentLevel * 0.5), 10);
            for (let i = 0; i < numEnemies; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * gameState.boardSize);
                    y = Math.floor(Math.random() * gameState.boardSize);
                } while (
                    gameState.player.pieces.some(p => p.alive && p.x === x && p.y === y) ||
                    (x === gameState.exit.x && y === gameState.exit.y) ||
                    gameState.enemies.some(e => e.x === x && e.y === y)
                );
                
                const enemyType = enemyTypes[Math.min(Math.floor(Math.random() * enemyTypes.length), gameState.currentLevel - 1)];
                const enemy = {
                    ...enemyType,
                    x,
                    y,
                };
                
                gameState.enemies.push(enemy);
            }
            
            // Generate items (more items as level increases)
            const numItems = Math.min(2 + Math.floor(gameState.currentLevel * 0.3), 5);
            for (let i = 0; i < numItems; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * gameState.boardSize);
                    y = Math.floor(Math.random() * gameState.boardSize);
                } while (
                    gameState.player.pieces.some(p => p.alive && p.x === x && p.y === y) ||
                    (x === gameState.exit.x && y === gameState.exit.y) ||
                    gameState.enemies.some(e => e.x === x && e.y === y) ||
                    gameState.items.some(item => item.x === x && item.y === y)
                );
                
                // 50% шанс фигуры, 25% шанс бонуса, 15% шанс звезды, 5% шанс постоянного эффекта, 4% шанс разового эффекта, 1% шанс специального объекта
                const random = Math.random();
                let selectedItem;
                
                if (random < 0.5) {
                    // Выбираем фигуру с учетом редкости
                    const pieceRandom = Math.random();
                    let cumulativeRarity = 0;
                    
                    for (const itemType of itemTypes) {
                        cumulativeRarity += itemType.rarity;
                        if (pieceRandom <= cumulativeRarity) {
                            selectedItem = itemType;
                            break;
                        }
                    }
                    
                    // Если ничего не выбрано, берем пешку (самую частую)
                    if (!selectedItem) {
                        selectedItem = itemTypes[0];
                    }
                } else if (random < 0.75) {
                    // Выбираем бонус
                    const bonusRandom = Math.random();
                    let cumulativeRarity = 0;
                    
                    for (const bonusItem of bonusItems) {
                        cumulativeRarity += bonusItem.rarity;
                        if (bonusRandom <= cumulativeRarity) {
                            selectedItem = bonusItem;
                            break;
                        }
                    }
                    
                    // Если ничего не выбрано, берем золото
                    if (!selectedItem) {
                        selectedItem = bonusItems[0];
                    }
                } else if (random < 0.9) {
                    // Выбираем звезду
                    selectedItem = starItem;
                } else if (random < 0.95) {
                    // Выбираем постоянный эффект
                    const effectRandom = Math.random();
                    let cumulativeRarity = 0;
                    
                    for (const effect of permanentEffects) {
                        cumulativeRarity += effect.rarity;
                        if (effectRandom <= cumulativeRarity) {
                            selectedItem = {
                                name: effect.name,
                                symbol: effect.symbol,
                                color: effect.color,
                                effect: 'permanent_effect',
                                value: effect.id,
                                description: effect.description
                            };
                            break;
                        }
                    }
                    
                    // Если ничего не выбрано, берем самый частый эффект
                    if (!selectedItem) {
                        const mostCommonEffect = permanentEffects.find(e => e.id === 'gold_boost');
                        selectedItem = {
                            name: mostCommonEffect.name,
                            symbol: mostCommonEffect.symbol,
                            color: mostCommonEffect.color,
                            effect: 'permanent_effect',
                            value: mostCommonEffect.id,
                            description: mostCommonEffect.description
                        };
                    }
                } else if (random < 0.99) {
                    // Выбираем разовый эффект
                    const oneTimeRandom = Math.random();
                    let cumulativeRarity = 0;
                    
                    for (const effect of oneTimeEffects) {
                        cumulativeRarity += effect.rarity;
                        if (oneTimeRandom <= cumulativeRarity) {
                            selectedItem = {
                                name: effect.name,
                                symbol: effect.symbol,
                                color: effect.color,
                                effect: 'one_time_effect',
                                value: effect.id,
                                description: effect.description
                            };
                            break;
                        }
                    }
                    
                    // Если ничего не выбрано, берем самый частый разовый эффект
                    if (!selectedItem) {
                        const mostCommonOneTime = oneTimeEffects.find(e => e.id === 'add_pawn');
                        selectedItem = {
                            name: mostCommonOneTime.name,
                            symbol: mostCommonOneTime.symbol,
                            color: mostCommonOneTime.color,
                            effect: 'one_time_effect',
                            value: mostCommonOneTime.id,
                            description: mostCommonOneTime.description
                        };
                    }
                } else {
                    // Выбираем специальный объект (ультра редко)
                    const specialRandom = Math.random();
                    let cumulativeRarity = 0;
                    
                    for (const specialItem of specialItems) {
                        cumulativeRarity += specialItem.rarity;
                        if (specialRandom <= cumulativeRarity) {
                            selectedItem = specialItem;
                            break;
                        }
                    }
                    
                    // Если ничего не выбрано, берем бриллиант
                    if (!selectedItem) {
                        selectedItem = specialItems[0];
                    }
                }
                
                gameState.items.push({
                    ...selectedItem,
                    x,
                    y
                });
            }
            
            // Update UI
            updateUI();
            renderBoard();
            addMessage(`Entered level ${gameState.currentLevel}`);
        }
        
        // Move enemies (теперь ходит только одна фигура за раз)
        function moveEnemies() {
            // Проверяем, отключен ли ИИ
            if (isEffectActive('ai_disabled')) {
                addMessage("AI is disabled - enemies skip their turn!");
                return;
            }
            
            if (gameState.enemies.length === 0) return;
            
            // Определяем количество ходов врагов
            const movesCount = isEffectActive('double_ai') ? 2 : 1;
            
            for (let move = 0; move < movesCount; move++) {
                // Выбираем случайную фигуру для хода
                const randomEnemyIndex = Math.floor(Math.random() * gameState.enemies.length);
                const enemy = gameState.enemies[randomEnemyIndex];
                
                // Получаем возможные ходы для этой фигуры
                const moves = movementPatterns[enemy.piece];
                const possibleMoves = [];
                const attackMoves = []; // Ходы для атаки фигур игрока
                
                // Для пешки - ходы прямо, атаки по диагонали
                if (enemy.piece === 'pawn') {
                    const moveDirections = [
                        { x: 0, y: 1 }, { x: 0, y: -1 },
                        { x: 1, y: 0 }, { x: -1, y: 0 }
                    ];
                    
                    const attackDirections = [
                        { x: 1, y: 1 }, { x: 1, y: -1 },
                        { x: -1, y: 1 }, { x: -1, y: -1 }
                    ];
                    
                    // Проверяем обычные ходы (только на пустые клетки)
                    moveDirections.forEach(dir => {
                        const newX = enemy.x + dir.x;
                        const newY = enemy.y + dir.y;
                        
                        if (newX >= 0 && newX < gameState.boardSize && 
                            newY >= 0 && newY < gameState.boardSize &&
                            !gameState.enemies.some(e => e !== enemy && e.x === newX && e.y === newY) &&
                            !(newX === gameState.exit.x && newY === gameState.exit.y) &&
                            !gameState.items.some(item => item.x === newX && item.y === newY) &&
                            !gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY)) {
                            
                            possibleMoves.push({ x: newX, y: newY });
                        }
                    });
                    
                    // Проверяем атаки по диагонали (только на клетки с фигурами игрока)
                    attackDirections.forEach(dir => {
                        const newX = enemy.x + dir.x;
                        const newY = enemy.y + dir.y;
                        
                        if (newX >= 0 && newX < gameState.boardSize && 
                            newY >= 0 && newY < gameState.boardSize) {
                            
                            // Проверяем, есть ли фигура игрока на этой клетке
                            const playerPiece = gameState.player.pieces.find(p => p.alive && p.x === newX && p.y === newY);
                            if (playerPiece) {
                                attackMoves.push({ x: newX, y: newY, targetPiece: playerPiece });
                            }
                        }
                    });
                } else {
                    // Для других фигур - используем их паттерны движения
                    moves.forEach(move => {
                        const newX = enemy.x + move.x;
                        const newY = enemy.y + move.y;
                        
                        if (newX >= 0 && newX < gameState.boardSize && 
                            newY >= 0 && newY < gameState.boardSize &&
                            !gameState.enemies.some(e => e !== enemy && e.x === newX && e.y === newY) &&
                            !(newX === gameState.exit.x && newY === gameState.exit.y) &&
                            !gameState.items.some(item => item.x === newX && item.y === newY)) {
                            
                            // Проверяем путь для фигур, которые не могут перепрыгивать
                            if (['rook', 'bishop', 'queen'].includes(enemy.piece)) {
                                if (!isPathClear(enemy.x, enemy.y, newX, newY)) {
                                    return; // Путь заблокирован
                                }
                            }
                            
                            // Проверяем, есть ли фигура игрока на этой клетке
                            const playerPiece = gameState.player.pieces.find(p => p.alive && p.x === newX && p.y === newY);
                            if (playerPiece) {
                                attackMoves.push({ x: newX, y: newY, targetPiece: playerPiece });
                            } else {
                                possibleMoves.push({ x: newX, y: newY });
                            }
                        }
                    });
                }
                
                // Приоритет атаки на ценные фигуры
                if (attackMoves.length > 0) {
                    // Сортируем по ценности фигур (король > ферзь > ладья > слон > конь > пешка)
                    const pieceValue = { 'king': 6, 'queen': 5, 'rook': 4, 'bishop': 3, 'knight': 2, 'pawn': 1 };
                    attackMoves.sort((a, b) => 
                        (pieceValue[b.targetPiece.type] || 0) - (pieceValue[a.targetPiece.type] || 0)
                    );
                    
                    const bestAttack = attackMoves[0];
                    const oldX = enemy.x;
                    const oldY = enemy.y;
                    enemy.x = bestAttack.x;
                    enemy.y = bestAttack.y;
                    
                    const fromCoord = getChessCoordinates(oldX, oldY);
                    const toCoord = getChessCoordinates(enemy.x, enemy.y);
                    addMessage(`Enemy ${enemy.name} moved from ${fromCoord} to ${toCoord} and attacked your ${bestAttack.targetPiece.type}!`);
                    
                    // Убиваем фигуру игрока
                    const attackedPieceIndex = gameState.player.pieces.findIndex(p => p === bestAttack.targetPiece);
                    gameState.player.pieces[attackedPieceIndex].alive = false;
                    
                    // Если это была активная фигура, выбираем другую живую
                    if (attackedPieceIndex === gameState.player.activePieceIndex) {
                        const alivePieces = gameState.player.pieces.filter(p => p.alive);
                        if (alivePieces.length > 0) {
                            const newActiveIndex = gameState.player.pieces.findIndex(p => p === alivePieces[0]);
                            gameState.player.activePieceIndex = newActiveIndex;
                            addMessage(`Switched to ${alivePieces[0].type} piece!`);
                        } else {
                            // Все фигуры мертвы - игра окончена
                            addMessage("All your pieces were captured! Game Over!");
                            setTimeout(() => {
                                gameOver();
                            }, 1000);
                            return;
                        }
                    }
                }
                // Если нет атак, делаем обычный ход
                else if (possibleMoves.length > 0) {
                    const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    const oldX = enemy.x;
                    const oldY = enemy.y;
                    enemy.x = move.x;
                    enemy.y = move.y;
                    
                    const fromCoord = getChessCoordinates(oldX, oldY);
                    const toCoord = getChessCoordinates(enemy.x, enemy.y);
                    addMessage(`Enemy ${enemy.name} moved from ${fromCoord} to ${toCoord}`);
                }
            }
        }
        
        // Attack an enemy (теперь просто съедаем фигуру)
        function attackEnemy(enemyIndex) {
            const enemy = gameState.enemies[enemyIndex];
            
            // Проверяем, может ли текущая фигура съесть врага
            const currentPiece = gameState.player.pieces[gameState.player.activePieceIndex].type;
            const canCapture = canPieceCapture(currentPiece, enemy.piece);
            
            if (!canCapture) {
                addMessage(`Your ${currentPiece} cannot capture ${enemy.name}!`);
                return;
            }
            
            // Запоминаем позицию врага
            const enemyX = enemy.x;
            const enemyY = enemy.y;
            
            // Съедаем врага
            const baseScoreGain = 10 * gameState.currentLevel;
            const scoreMultiplier = getScoreMultiplier();
            const scoreGain = Math.floor(baseScoreGain * scoreMultiplier);
            gameState.score += scoreGain;
            gameState.player.kills++;
            
            if (scoreMultiplier > 1.0) {
                addMessage(`You captured the ${enemy.name} and gained ${scoreGain} points! (${baseScoreGain} + ${Math.floor((scoreMultiplier - 1) * 100)}% bonus)`);
            } else {
                addMessage(`You captured the ${enemy.name} and gained ${scoreGain} points!`);
            }
            gameState.enemies.splice(enemyIndex, 1);
            
            // Проверяем, был ли это последний враг - если да, показываем дверь
            if (gameState.enemies.length === 0) {
                addMessage("All enemies defeated! The exit is now available!");
                // Обновляем доску, чтобы показать дверь
                renderBoard();
            }
            
            // Игрок занимает позицию срубленной фигуры
            gameState.player.pieces[gameState.player.activePieceIndex].x = enemyX;
            gameState.player.pieces[gameState.player.activePieceIndex].y = enemyY;
            
            // Проверяем достижения
            if (gameState.player.pieces[gameState.player.activePieceIndex].type === 'pawn' && gameState.player.kills >= 5) {
                // Случайное повышение пешки с разными шансами
                const promotionChance = Math.random();
                let newType;
                
                if (promotionChance < 0.05) {
                    // 5% шанс на ферзя (самый редкий)
                    newType = 'queen';
                    addMessage("Your pawn has been promoted to a queen! (Ultra rare!)");
                } else if (promotionChance < 0.15) {
                    // 10% шанс на ладью
                    newType = 'rook';
                    addMessage("Your pawn has been promoted to a rook! (Rare!)");
                } else if (promotionChance < 0.30) {
                    // 15% шанс на слона
                    newType = 'bishop';
                    addMessage("Your pawn has been promoted to a bishop!");
                } else if (promotionChance < 0.50) {
                    // 20% шанс на коня
                    newType = 'knight';
                    addMessage("Your pawn has been promoted to a knight!");
                } else {
                    // 50% шанс остаться пешкой (но с улучшенными характеристиками)
                    newType = 'pawn';
                    addMessage("Your pawn gained experience but remains a pawn!");
                }
                
                gameState.player.pieces[gameState.player.activePieceIndex].type = newType;
            }
            
            // Ход врагов
            gameState.currentTurn = 'enemy';
            setTimeout(() => {
                moveEnemies();
                gameState.currentTurn = 'player';
                renderBoard();
                updateUI();
            }, 500);
        }
        
        // Функция для проверки, может ли фигура съесть другую
        function canPieceCapture(attacker, defender) {
            // В шахматах любая фигура может съесть любую другую фигуру
            // Ограничения только в правилах движения, а не в иерархии силы
            return true;
        }
        
        // Complete the level
        function completeLevel() {
            // Calculate rewards with multipliers
            const baseGoldGain = Math.floor(Math.random() * 10 * gameState.currentLevel) + 5;
            const goldMultiplier = getGoldMultiplier();
            const goldGain = Math.floor(baseGoldGain * goldMultiplier);
            
            const baseScoreGain = 50 * gameState.currentLevel;
            const scoreMultiplier = getScoreMultiplier();
            const scoreGain = Math.floor(baseScoreGain * scoreMultiplier);
            
            gameState.player.gold += goldGain;
            gameState.score += scoreGain;
            
            // Показываем сообщение о множителях, если они активны
            if (goldMultiplier > 1.0) {
                addMessage(`Gold Magnet: +${Math.floor((goldMultiplier - 1) * 100)}% bonus gold!`);
            }
            if (scoreMultiplier > 1.0) {
                addMessage(`Score Multiplier: +${Math.floor((scoreMultiplier - 1) * 100)}% bonus points!`);
            }
            
            // Очищаем временные эффекты
            clearTemporaryEffects();
            
            // Сохраняем живые фигуры для следующего уровня
            const alivePieces = gameState.player.pieces.filter(p => p.alive);
            gameState.player.pieces = alivePieces;
            
            // Если нет живых фигур, создаем новую пешку
            if (gameState.player.pieces.length === 0) {
                gameState.player.pieces = [{ type: 'pawn', x: 0, y: 0, alive: true, isActive: true }];
            }
            
            // Сбрасываем активную фигуру на первую
            gameState.player.activePieceIndex = 0;
            
            // Update level complete modal
            document.getElementById('level-gold').textContent = goldGain;
            document.getElementById('level-items').textContent = '0'; // Убираем предметы
            
            // Show level complete screen
            document.getElementById('level-complete-modal').classList.add('flex');
            
            // Показываем рекламу при завершении уровня (каждый 3-й уровень)
            if (gameState.currentLevel % 3 === 0) {
                setTimeout(() => {
                    showAdOnLevelComplete();
                }, 1000);
            }
            
            // Показываем магазин между уровнями (каждый 2-й уровень)
            if (gameState.currentLevel % 2 === 0) {
                setTimeout(() => {
                    document.getElementById('level-complete-modal').classList.remove('flex');
                    showShop();
                }, 2000);
            }
        }
        
        // Game over
        function gameOver() {
            // Update game over modal
            document.getElementById('final-level').textContent = gameState.currentLevel;
            document.getElementById('final-score-value').textContent = gameState.score;
            
            // Show game over screen
            document.getElementById('game-over-modal').classList.add('flex');
            
            // Показываем рекламу при смерти игрока
            setTimeout(() => {
                showAdOnGameOver();
            }, 1000);
            showInterstitialAd();
            
            // Проверяем доступность rewarded рекламы для кнопки Revive
            const plugin = Capacitor.Plugins.MyTargetPlugin || window.Capacitor?.Plugins?.MyTargetPlugin;
            if (plugin) {
                plugin.isRewardedReady()
                    .then((result) => {
                        const reviveBtn = document.getElementById('revive-button');
                        if (result && result.ready) {
                            reviveBtn.disabled = false;
                            console.log('Revive button enabled - rewarded ad ready');
                        } else {
                            reviveBtn.disabled = true;
                            console.log('Revive button disabled - rewarded ad not ready');
                        }
                    })
                    .catch(err => {
                        console.log('Error checking rewarded ad status:', err);
                        document.getElementById('revive-button').disabled = true;
                    });
            } else {
                // Fallback для браузера
                console.log('MyTargetPlugin not available - revive button disabled');
                document.getElementById('revive-button').disabled = true;
            }
        }
        
        // Обработчик кнопки Revive
        document.addEventListener('DOMContentLoaded', function() {
            const reviveBtn = document.getElementById('revive-button');
            if (reviveBtn) {
                reviveBtn.addEventListener('click', function() {
                    const plugin = Capacitor.Plugins.MyTargetPlugin || window.Capacitor?.Plugins?.MyTargetPlugin;
                    if (plugin) {
                        console.log('Showing rewarded ad for revive...');
                        plugin.showRewardedAd()
                            .then(() => {
                                console.log('Rewarded ad shown successfully');
                            })
                            .catch(err => {
                                console.log('Error showing rewarded ad:', err);
                                // Fallback - даем награду без рекламы в случае ошибки
                                revivePlayer();
                            });
                    } else {
                        // Fallback для браузера - сразу возрождаем
                        console.log('MyTargetPlugin not available - reviving without ad');
                        revivePlayer();
                    }
                });
            }
        });
        
        // Слушаем событие о получении награды от rewarded рекламы
        document.addEventListener('rewardedAdCompleted', function() {
            console.log('Rewarded ad completed - reviving player');
            revivePlayer();
        });
        
        // Update UI elements
        function updateUI() {
            checkAndUnlockAchievements();
            document.getElementById('current-level').textContent = gameState.currentLevel;
            document.getElementById('current-score').textContent = gameState.score;
            document.getElementById('current-attack').textContent = gameState.player.pieces[gameState.player.activePieceIndex].type;
            document.getElementById('current-gold').textContent = gameState.player.gold;
            
            // Update inventory
            const inventoryElement = document.getElementById('inventory');
            inventoryElement.innerHTML = '';
            
            // Показываем активные временные эффекты
            gameState.effects.temporary.forEach(effectId => {
                const effect = temporaryEffects.find(e => e.id === effectId);
                if (effect) {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'inventory-item';
                    
                    // Используем спрайт для эффекта
                    const imgElement = document.createElement('img');
                    imgElement.src = getEffectSprite(effect.id);
                    imgElement.style.width = '100%';
                    imgElement.style.height = '100%';
                    imgElement.style.objectFit = 'contain';
                    imgElement.style.imageRendering = 'pixelated';
                    itemElement.appendChild(imgElement);
                    
                    // Add tooltip
                    itemElement.addEventListener('mouseenter', (e) => {
                        const tooltip = document.getElementById('tooltip');
                        const effectType = effect.type === 'positive' ? '✅' : '❌';
                        tooltip.textContent = `${effectType} ${effect.name}: ${effect.description}`;
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${e.pageX}px`;
                        tooltip.style.top = `${e.pageY - 30}px`;
                    });
                    
                    itemElement.addEventListener('mouseleave', () => {
                        document.getElementById('tooltip').style.display = 'none';
                    });
                    
                    inventoryElement.appendChild(itemElement);
                }
            });
            
            // Показываем постоянные эффекты (когда они будут добавлены)
            gameState.effects.permanent.forEach(effectId => {
                const effect = permanentEffects.find(e => e.id === effectId);
                if (effect) {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'inventory-item';
                    
                    // Используем спрайт для эффекта
                    const imgElement = document.createElement('img');
                    imgElement.src = getEffectSprite(effect.id);
                    imgElement.style.width = '100%';
                    imgElement.style.height = '100%';
                    imgElement.style.objectFit = 'contain';
                    imgElement.style.imageRendering = 'pixelated';
                    itemElement.appendChild(imgElement);
                    
                    itemElement.style.border = '2px solid gold'; // Отличительная рамка для постоянных эффектов
                    
                    // Add tooltip
                    itemElement.addEventListener('mouseenter', (e) => {
                        const tooltip = document.getElementById('tooltip');
                        const effectType = effect.type === 'positive' ? '✅' : '❌';
                        tooltip.textContent = `${effectType} ${effect.name} (PERMANENT): ${effect.description}`;
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${e.pageX}px`;
                        tooltip.style.top = `${e.pageY - 30}px`;
                    });
                    
                    itemElement.addEventListener('mouseleave', () => {
                        document.getElementById('tooltip').style.display = 'none';
                    });
                    
                    inventoryElement.appendChild(itemElement);
                }
            });
            
            // Показываем разовые эффекты (если они активны)
            gameState.effects.oneTime.forEach(effectId => {
                const effect = oneTimeEffects.find(e => e.id === effectId);
                if (effect) {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'inventory-item';
                    
                    // Используем спрайт для эффекта
                    const imgElement = document.createElement('img');
                    imgElement.src = getEffectSprite(effect.id);
                    imgElement.style.width = '100%';
                    imgElement.style.height = '100%';
                    imgElement.style.objectFit = 'contain';
                    imgElement.style.imageRendering = 'pixelated';
                    itemElement.appendChild(imgElement);
                    
                    itemElement.style.border = '2px solid purple'; // Отличительная рамка для разовых эффектов
                    
                    // Add tooltip
                    itemElement.addEventListener('mouseenter', (e) => {
                        const tooltip = document.getElementById('tooltip');
                        const effectType = effect.type === 'positive' ? '✅' : '❌';
                        tooltip.textContent = `${effectType} ${effect.name} (ONE-TIME): ${effect.description}`;
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${e.pageX}px`;
                        tooltip.style.top = `${e.pageY - 30}px`;
                    });
                    
                    itemElement.addEventListener('mouseleave', () => {
                        document.getElementById('tooltip').style.display = 'none';
                    });
                    
                    inventoryElement.appendChild(itemElement);
                }
            });
        }
        
        // Add message to log
        function addMessage(text) {
            gameState.messages.unshift(text);
            if (gameState.messages.length > 5) {
                gameState.messages.pop();
            }
            
            const messageLog = document.getElementById('message-log');
            messageLog.innerHTML = gameState.messages.map(msg => `<div>${msg}</div>`).join('');
        }
        
        // Hide moves when clicking elsewhere on the board
        document.getElementById('game-board').addEventListener('click', (e) => {
            if (!e.target.classList.contains('available-move') && !e.target.classList.contains('player')) {
                document.querySelectorAll('.available-move').forEach(el => el.remove());
            }
        });

        // Initialize the game when page loads
        window.onload = initGame;

        // Попытка скрыть системные панели на Android
        document.addEventListener('DOMContentLoaded', function() {
            if (window.AndroidFullScreen && window.AndroidFullScreen.immersiveMode) {
                window.AndroidFullScreen.immersiveMode();
            } else if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.StatusBar) {
                window.Capacitor.Plugins.StatusBar.hide();
            }
        });

        // Collect an item
        function collectItem(itemIndex) {
            const item = gameState.items[itemIndex];
            
            // Добавляем предмет в инвентарь для подсчёта достижений
            gameState.player.inventory.push({ ...item });
            
            // Apply item effect
            switch(item.effect) {
                case 'piece':
                    // Проверяем, есть ли свободное место для новой фигуры
                    if (gameState.player.pieces.length >= 16) { // Максимум 16 фигур
                        addMessage(`You can't carry more pieces! Maximum reached.`);
                        return;
                    }
                    
                    // Ищем случайную свободную клетку на поле
                    let newX, newY;
                    let attempts = 0;
                    let isOccupied;
                    do {
                        newX = Math.floor(Math.random() * gameState.boardSize);
                        newY = Math.floor(Math.random() * gameState.boardSize);
                        attempts++;
                        
                        // Проверяем, что клетка свободна
                        isOccupied = gameState.enemies.some(e => e.x === newX && e.y === newY) ||
                                          gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY) ||
                                          gameState.items.some(item => item.x === newX && item.y === newY) ||
                                          (newX === gameState.exit.x && newY === gameState.exit.y);
                    } while (isOccupied && attempts < 50);
                    
                    // Если не нашли свободную клетку, размещаем в углу
                    if (attempts >= 50) {
                        const cornerIndex = gameState.player.pieces.length;
                        newX = (cornerIndex - 1) % 4;
                        newY = Math.floor((cornerIndex - 1) / 4);
                    }
                    
                    gameState.player.pieces.push({ 
                        type: item.value, 
                        x: newX, 
                        y: newY, 
                        alive: true, 
                        isActive: false 
                    });
                    addMessage(`You collected a ${item.name}! Now you have ${gameState.player.pieces.length} pieces.`);
                    break;
                case 'gold':
                    const baseGoldValue = item.value;
                    const goldMultiplier = getGoldMultiplier();
                    const actualGoldValue = Math.floor(baseGoldValue * goldMultiplier);
                    gameState.player.gold += actualGoldValue;
                    
                    if (goldMultiplier > 1.0) {
                        addMessage(`You found ${actualGoldValue} gold! (${baseGoldValue} + ${Math.floor((goldMultiplier - 1) * 100)}% bonus)`);
                    } else {
                        addMessage(`You found ${actualGoldValue} gold!`);
                    }
                    break;
                case 'random_effect':
                    // Выбираем случайный эффект
                    const randomEffect = temporaryEffects[Math.floor(Math.random() * temporaryEffects.length)];
                    applyTemporaryEffect(randomEffect.id);
                    addMessage(`⭐ Mystery Star gave you: ${randomEffect.name}!`);
                    break;
                case 'permanent_effect':
                    // Применяем постоянный эффект
                    applyPermanentEffect(item.value);
                    break;
                case 'one_time_effect':
                    // Применяем разовый эффект
                    applyOneTimeEffect(item.value);
                    break;
            }
            
            // Remove item from board
            gameState.items.splice(itemIndex, 1);
        }
        
        // Render the game board
        function renderBoard() {
            const boardElement = document.getElementById('game-board');
            boardElement.innerHTML = '';
            
            // Calculate cell size based on board size
            const boardRect = boardElement.getBoundingClientRect();
            const cellSize = Math.min(boardRect.width, boardRect.height) / gameState.boardSize;
            
            // Set board dimensions and center it
            const boardWidth = gameState.boardSize * cellSize;
            const boardHeight = gameState.boardSize * cellSize;
            boardElement.style.width = `${boardWidth}px`;
            boardElement.style.height = `${boardHeight}px`;
            boardElement.style.margin = '0'; // Убираем центрирование
            
            // Create board squares
            for (let y = 0; y < gameState.boardSize; y++) {
                for (let x = 0; x < gameState.boardSize; x++) {
                    const isLightSquare = (x + y) % 2 === 0;
                    const square = document.createElement('img');
                    square.className = 'floor-square';
                    square.src = getFloorSprite(isLightSquare);
                    square.style.position = 'absolute';
                    square.style.width = `${cellSize}px`;
                    square.style.height = `${cellSize}px`;
                    square.style.left = `${x * cellSize}px`;
                    square.style.top = `${y * cellSize}px`;
                    square.style.objectFit = 'cover';
                    square.style.imageRendering = 'pixelated';
                    square.style.zIndex = '0';
                    boardElement.appendChild(square);
                }
            }
            
            // Draw exit (скрыта по умолчанию, появляется когда все враги побеждены)
            const exit = document.createElement('img');
            exit.className = 'exit';
            exit.src = getStairSprite();
            exit.style.left = `${gameState.exit.x * cellSize}px`;
            exit.style.top = `${gameState.exit.y * cellSize}px`;
            exit.style.width = `${cellSize}px`;
            exit.style.height = `${cellSize}px`;
            exit.style.objectFit = 'contain';
            exit.style.imageRendering = 'pixelated';
            // Показываем дверь только если все враги побеждены или активен ключ
            if (gameState.enemies.length === 0 || isEffectActive('master_key')) {
                exit.classList.add('visible');
            }
            boardElement.appendChild(exit);
            
            // Draw items
            gameState.items.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'item';
                
                // Если это фигура, используем изображение
                if (item.effect === 'piece') {
                    const imgElement = document.createElement('img');
                    imgElement.src = getItemFigureSprite(item.value);
                    imgElement.style.width = '100%';
                    imgElement.style.height = '100%';
                    imgElement.style.objectFit = 'contain';
                    imgElement.style.imageRendering = 'pixelated';
                    itemElement.appendChild(imgElement);
                } else {
                    // Для других предметов используем спрайты
                    const imgElement = document.createElement('img');
                    let spritePath;
                    
                    if (item.effect === 'gold') {
                        spritePath = getItemSprite('gold');
                    } else if (item.effect === 'random_effect') {
                        spritePath = getItemSprite('mystery');
                    } else if (item.symbol === 'chest') {
                        spritePath = getItemSprite('chest');
                    } else if (item.symbol === 'slot') {
                        spritePath = getItemSprite('slot');
                    } else {
                        // Для остальных предметов используем символ как fallback
                itemElement.textContent = item.symbol;
                itemElement.style.color = item.color;
                    }
                    
                    if (spritePath) {
                        imgElement.src = spritePath;
                        imgElement.style.width = '100%';
                        imgElement.style.height = '100%';
                        imgElement.style.objectFit = 'contain';
                        imgElement.style.imageRendering = 'pixelated';
                        itemElement.appendChild(imgElement);
                    }
                }
                
                itemElement.style.left = `${item.x * cellSize}px`;
                itemElement.style.top = `${item.y * cellSize}px`;
                itemElement.style.width = `${cellSize}px`;
                itemElement.style.height = `${cellSize}px`;
                itemElement.style.lineHeight = `${cellSize}px`;
                itemElement.style.textAlign = 'center';
                itemElement.style.fontSize = `${Math.max(12, cellSize * 0.4)}px`;
                boardElement.appendChild(itemElement);
            });
            
            // Draw enemies
            gameState.enemies.forEach(enemy => {
                const enemyElement = document.createElement('img');
                enemyElement.className = 'enemy';
                enemyElement.src = getPieceImagePath(enemy.piece, false);
                enemyElement.style.left = `${enemy.x * cellSize}px`;
                enemyElement.style.top = `${enemy.y * cellSize}px`;
                enemyElement.style.width = `${cellSize}px`;
                enemyElement.style.height = `${cellSize}px`;
                enemyElement.style.objectFit = 'contain';
                enemyElement.style.imageRendering = 'pixelated';
                
                boardElement.appendChild(enemyElement);
            });
            
            // Draw player pieces (все живые фигуры игрока)
            gameState.player.pieces.forEach((piece, index) => {
                // Пропускаем мертвые фигуры
                if (!piece.alive) return;
                
            const playerElement = document.createElement('img');
            playerElement.className = 'player';
                playerElement.src = getPieceImagePath(piece.type, true);
                
                // Все фигуры отображаются на своих позициях
                playerElement.style.left = `${piece.x * cellSize}px`;
                playerElement.style.top = `${piece.y * cellSize}px`;
                
                // Дополнительные фигуры (не первая) имеют особое оформление
                if (index > 0) {
                    playerElement.style.opacity = '0.8';
                    playerElement.style.transform = 'scale(0.8)';
                    playerElement.style.border = '1px solid transparent';
                    playerElement.style.borderRadius = '2px';
                }
                
            playerElement.style.cursor = 'pointer';
                // Универсальный обработчик для всех фигур
                playerElement.addEventListener('click', () => {
                    selectPiece(index);
                    showAvailableMoves();
                });
                
                // Подсвечиваем активную фигуру
                if (index === gameState.player.activePieceIndex) {
                    playerElement.classList.add('active');
                    playerElement.style.border = '2px solid gold';
                    playerElement.style.boxShadow = '0 0 10px gold';
                    playerElement.style.opacity = '1';
                    playerElement.style.transform = 'scale(1)';
                }
                
                playerElement.style.width = `${cellSize}px`;
                playerElement.style.height = `${cellSize}px`;
                playerElement.style.objectFit = 'contain';
                playerElement.style.imageRendering = 'pixelated';
            boardElement.appendChild(playerElement);
            });
            
            // Draw dungeon walls
            const wallSize = cellSize; // Стены того же размера, что и клетки
            
            // Top wall
            for (let x = 0; x < gameState.boardSize; x++) {
                const wallElement = document.createElement('img');
                wallElement.className = 'wall';
                wallElement.src = gameState.topWalls[x];
                wallElement.style.position = 'absolute';
                wallElement.style.left = `${x * wallSize}px`;
                wallElement.style.top = `-${wallSize}px`;
                wallElement.style.width = `${wallSize}px`;
                wallElement.style.height = `${wallSize}px`;
                wallElement.style.objectFit = 'cover';
                wallElement.style.imageRendering = 'pixelated';
                wallElement.style.zIndex = '5';
                boardElement.appendChild(wallElement);
            }
            
            // Bottom wall
            for (let x = 0; x < gameState.boardSize; x++) {
                const wallElement = document.createElement('img');
                wallElement.className = 'wall';
                wallElement.src = gameState.bottomWalls[x];
                wallElement.style.position = 'absolute';
                wallElement.style.left = `${x * wallSize}px`;
                wallElement.style.top = `${gameState.boardSize * wallSize}px`;
                wallElement.style.width = `${wallSize}px`;
                wallElement.style.height = `${wallSize}px`;
                wallElement.style.objectFit = 'cover';
                wallElement.style.imageRendering = 'pixelated';
                wallElement.style.zIndex = '5';
                boardElement.appendChild(wallElement);
            }
            
            // Left side wall
            const leftWallElement = document.createElement('img');
            leftWallElement.className = 'wall';
            leftWallElement.src = getLeftWallSprite();
            leftWallElement.style.position = 'absolute';
            leftWallElement.style.left = `-${wallSize}px`;
            leftWallElement.style.top = `0px`;
            leftWallElement.style.width = `${wallSize}px`;
            leftWallElement.style.height = `${gameState.boardSize * wallSize}px`;
            leftWallElement.style.objectFit = 'cover';
            leftWallElement.style.imageRendering = 'pixelated';
            leftWallElement.style.zIndex = '5';
            boardElement.appendChild(leftWallElement);
            
            // Right side wall
            const rightWallElement = document.createElement('img');
            rightWallElement.className = 'wall';
            rightWallElement.src = getRightWallSprite();
            rightWallElement.style.position = 'absolute';
            rightWallElement.style.left = `${gameState.boardSize * wallSize}px`;
            rightWallElement.style.top = `0px`;
            rightWallElement.style.width = `${wallSize}px`;
            rightWallElement.style.height = `${gameState.boardSize * wallSize}px`;
            rightWallElement.style.objectFit = 'cover';
            rightWallElement.style.imageRendering = 'pixelated';
            rightWallElement.style.zIndex = '5';
            boardElement.appendChild(rightWallElement);
            
            // Add coordinate labels (поверх стен)
            const coordinateSize = Math.max(20, cellSize * 0.3);
            
            // Add top coordinate labels (A-H)
            for (let x = 0; x < gameState.boardSize; x++) {
                const coordLabel = document.createElement('div');
                coordLabel.className = 'coordinate-label';
                coordLabel.textContent = String.fromCharCode(65 + x); // A, B, C, D, E, F, G, H
                coordLabel.style.position = 'absolute';
                coordLabel.style.left = `${x * cellSize}px`;
                coordLabel.style.top = `-${coordinateSize}px`;
                coordLabel.style.width = `${cellSize}px`;
                coordLabel.style.height = `${coordinateSize}px`;
                coordLabel.style.textAlign = 'center';
                coordLabel.style.lineHeight = `${coordinateSize}px`;
                coordLabel.style.fontSize = `${Math.max(10, coordinateSize * 0.6)}px`;
                coordLabel.style.color = '#000';
                coordLabel.style.fontWeight = 'bold';
                coordLabel.style.zIndex = '10';
                boardElement.appendChild(coordLabel);
            }
            
            // Add left coordinate labels (1-8)
            for (let y = 0; y < gameState.boardSize; y++) {
                const coordLabel = document.createElement('div');
                coordLabel.className = 'coordinate-label';
                coordLabel.textContent = gameState.boardSize - y; // 8, 7, 6, 5, 4, 3, 2, 1
                coordLabel.style.position = 'absolute';
                coordLabel.style.left = `-${coordinateSize}px`;
                coordLabel.style.top = `${y * cellSize}px`;
                coordLabel.style.width = `${coordinateSize}px`;
                coordLabel.style.height = `${cellSize}px`;
                coordLabel.style.textAlign = 'center';
                coordLabel.style.lineHeight = `${cellSize}px`;
                coordLabel.style.fontSize = `${Math.max(10, coordinateSize * 0.6)}px`;
                coordLabel.style.color = '#000';
                coordLabel.style.fontWeight = 'bold';
                coordLabel.style.zIndex = '10';
                boardElement.appendChild(coordLabel);
            }
        }
        
        // Get piece symbol based on piece type
        function getPieceSymbol(pieceType) {
            switch(pieceType) {
                case 'pawn': return '♙';
                case 'knight': return '♘';
                case 'bishop': return '♗';
                case 'rook': return '♖';
                case 'queen': return '♕';
                case 'king': return '♔';
                default: return '♙';
            }
        }
        
        // Get player symbol based on selected piece
        function getPlayerSymbol() {
            return getPieceSymbol(gameState.player.pieces[gameState.player.activePieceIndex].type);
        }
        
        // Show available moves when player is clicked
        function showAvailableMoves() {
            // Clear any existing move indicators
            document.querySelectorAll('.available-move').forEach(el => el.remove());
            
            const boardElement = document.getElementById('game-board');
            const boardRect = boardElement.getBoundingClientRect();
            const cellSize = Math.min(boardRect.width, boardRect.height) / gameState.boardSize;
            
            const activePiece = gameState.player.pieces[gameState.player.activePieceIndex];
            const moves = movementPatterns[activePiece.type];
            
            // Special case for pawn (can move in 4 directions, but capture diagonally)
            if (activePiece.type === 'pawn') {
                const moveDirections = [
                    { x: 0, y: 1 },  // Down
                    { x: 0, y: -1 }, // Up
                    { x: 1, y: 0 },  // Right
                    { x: -1, y: 0 }  // Left
                ];
                
                const captureDirections = [
                    { x: 1, y: 1 },   // Down-Right
                    { x: 1, y: -1 },  // Up-Right
                    { x: -1, y: 1 },  // Down-Left
                    { x: -1, y: -1 }  // Up-Left
                ];
                
                // Показываем ходы (только на пустые клетки)
                moveDirections.forEach(dir => {
                    const newX = activePiece.x + dir.x;
                    const newY = activePiece.y + dir.y;
                    
                    if (newX >= 0 && newX < gameState.boardSize && newY >= 0 && newY < gameState.boardSize) {
                        // Проверяем выход (разрешаем ходить на выход, если все враги побеждены)
                        const isExit = (newX === gameState.exit.x && newY === gameState.exit.y);
                        
                        // Проверяем, что клетка не занята другими фигурами игрока
                        const isOccupiedByPlayer = gameState.player.pieces.some((piece, idx) => 
                            piece.alive && idx !== gameState.player.activePieceIndex && 
                            piece.x === newX && piece.y === newY
                        );
                        
                        // Проверяем, что клетка не занята врагом (пешка не может ходить на клетку с врагом)
                        const isOccupiedByEnemy = gameState.enemies.some(e => e.x === newX && e.y === newY);
                        
                        if ((!isExit || (isExit && (gameState.enemies.length === 0 || isEffectActive('master_key')))) && !isOccupiedByPlayer && !isOccupiedByEnemy) {
                        const moveElement = document.createElement('div');
                        moveElement.className = 'available-move';
                            moveElement.style.left = `${newX * cellSize}px`;
                            moveElement.style.top = `${newY * cellSize}px`;
                            moveElement.style.width = `${cellSize}px`;
                            moveElement.style.height = `${cellSize}px`;
                        moveElement.addEventListener('click', () => attemptMove(dir.x, dir.y));
                        boardElement.appendChild(moveElement);
                    }
                    }
                });
                
                // Показываем атаки (только на клетки с врагами)
                captureDirections.forEach(dir => {
                    const newX = activePiece.x + dir.x;
                    const newY = activePiece.y + dir.y;
                    
                    if (newX >= 0 && newX < gameState.boardSize && newY >= 0 && newY < gameState.boardSize) {
                        // Проверяем, есть ли враг на этой клетке
                        const enemyIndex = gameState.enemies.findIndex(e => e.x === newX && e.y === newY);
                        
                        if (enemyIndex !== -1) {
                            const moveElement = document.createElement('div');
                            moveElement.className = 'available-move';
                            moveElement.style.backgroundColor = 'rgba(255, 0, 0, 0.3)'; // Красный для атаки
                            moveElement.style.left = `${newX * cellSize}px`;
                            moveElement.style.top = `${newY * cellSize}px`;
                            moveElement.style.width = `${cellSize}px`;
                            moveElement.style.height = `${cellSize}px`;
                            moveElement.addEventListener('click', () => attemptMove(dir.x, dir.y));
                            boardElement.appendChild(moveElement);
                        }
                    }
                });
            }
            // For other pieces, show all valid moves with path checking
            else {
                moves.forEach(move => {
                    const newX = activePiece.x + move.x;
                    const newY = activePiece.y + move.y;
                    
                    if (newX >= 0 && newX < gameState.boardSize && newY >= 0 && newY < gameState.boardSize) {
                        // Проверяем путь для фигур, которые не могут перепрыгивать
                        if (['rook', 'bishop', 'queen'].includes(activePiece.type)) {
                            if (!isPathClear(activePiece.x, activePiece.y, newX, newY)) {
                                return; // Путь заблокирован
                            }
                        }
                        
                        // Проверяем выход (разрешаем ходить на выход, если все враги побеждены)
                        const isExit = (newX === gameState.exit.x && newY === gameState.exit.y);
                        
                        // Проверяем, что клетка не занята другими фигурами игрока
                        const isOccupiedByPlayer = gameState.player.pieces.some((piece, idx) => 
                            piece.alive && idx !== gameState.player.activePieceIndex && 
                            piece.x === newX && piece.y === newY
                        );
                        
                        if ((!isExit || (isExit && (gameState.enemies.length === 0 || isEffectActive('master_key')))) && !isOccupiedByPlayer) {
                        const moveElement = document.createElement('div');
                        moveElement.className = 'available-move';
                            moveElement.style.left = `${newX * cellSize}px`;
                            moveElement.style.top = `${newY * cellSize}px`;
                            moveElement.style.width = `${cellSize}px`;
                            moveElement.style.height = `${cellSize}px`;
                        moveElement.addEventListener('click', () => attemptMove(move.x, move.y));
                        boardElement.appendChild(moveElement);
                        }
                    }
                });
            }
        }
        
        // Функция для проверки свободности пути
        function isPathClear(fromX, fromY, toX, toY) {
            const dx = Math.sign(toX - fromX);
            const dy = Math.sign(toY - fromY);
            let x = fromX + dx;
            let y = fromY + dy;
            
            // Проверяем каждую клетку на пути до конечной точки
            while (x !== toX || y !== toY) {
                // Проверяем, не занята ли клетка врагом
                if (gameState.enemies.some(e => e.x === x && e.y === y)) {
                    return false;
                }
                // Проверяем, не занята ли клетка фигурой игрока
                if (gameState.player.pieces.some(p => p.alive && p.x === x && p.y === y)) {
                    return false;
                }
                // Проверяем, не занята ли клетка предметом
                if (gameState.items.some(item => item.x === x && item.y === y)) {
                    return false;
                }
                x += dx;
                y += dy;
            }
            return true;
        }

        // Handle keyboard input
        function handleKeyPress(e) {
            if (document.getElementById('game-container').classList.contains('hidden')) return;
            
            let dx = 0, dy = 0;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    dy = -1;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    dy = 1;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    dx = -1;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    dx = 1;
                    break;
                default:
                    return;
            }
            
            e.preventDefault();
            attemptMove(dx, dy);
        }
        
        // Convert coordinates to chess notation
        function getChessCoordinates(x, y) {
            const file = String.fromCharCode(65 + x); // A, B, C, D, E, F, G, H
            const rank = gameState.boardSize - y; // 8, 7, 6, 5, 4, 3, 2, 1
            return `${file}${rank}`;
        }
        
        // Attempt to move the player
        function attemptMove(dx, dy) {
            // Clear move indicators
            document.querySelectorAll('.available-move').forEach(el => el.remove());
            
            const activePiece = gameState.player.pieces[gameState.player.activePieceIndex];
            const oldX = activePiece.x;
            const oldY = activePiece.y;
            const newX = oldX + dx;
            const newY = oldY + dy;
            
            // Check if move is valid
            if (newX < 0 || newX >= gameState.boardSize || newY < 0 || newY >= gameState.boardSize) {
                addMessage("Can't move outside the board!");
                return;
            }
            
            // Check if move follows piece movement rules
            const validMoves = movementPatterns[activePiece.type];
            let isValidMove = false;
            
            // Special case for pawn (can move in 4 directions, but capture diagonally)
            if (activePiece.type === 'pawn') {
                const moveDirections = [
                    { x: 0, y: 1 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: -1, y: 0 }
                ];
                const captureDirections = [
                    { x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: -1, y: -1 }
                ];
                
                // Проверяем, есть ли враг на целевой клетке
                const enemyIndex = gameState.enemies.findIndex(e => e.x === newX && e.y === newY);
                
                if (enemyIndex !== -1) {
                    // Если есть враг, проверяем диагональные ходы для атаки
                    isValidMove = captureDirections.some(dir => dir.x === dx && dir.y === dy);
                } else {
                    // Если нет врага, проверяем прямые ходы
                    isValidMove = moveDirections.some(dir => dir.x === dx && dir.y === dy);
                }
            }
            // For other pieces, check if the move matches any pattern
            else {
                isValidMove = validMoves.some(move => move.x === dx && move.y === dy);
            }
            
            if (!isValidMove) {
                addMessage(`Invalid move for ${activePiece.type}!`);
                return;
            }
            
            // Check if target cell is occupied by another player piece
            const isOccupiedByPlayer = gameState.player.pieces.some((piece, idx) => 
                piece.alive && idx !== gameState.player.activePieceIndex && 
                piece.x === newX && piece.y === newY
            );
            
            if (isOccupiedByPlayer) {
                addMessage("Can't move to a cell occupied by another piece!");
                return;
            }
            
            // Check for exit
            if (newX === gameState.exit.x && newY === gameState.exit.y) {
                if (gameState.enemies.length === 0 || isEffectActive('master_key')) {
                    completeLevel();
                } else {
                    addMessage("You must defeat all enemies before exiting!");
                }
                return;
            }
            
            // Check for enemies
            const enemyIndex = gameState.enemies.findIndex(e => e.x === newX && e.y === newY);
            if (enemyIndex !== -1) {
                attackEnemy(enemyIndex);
                return;
            }
            
            // Check for items
            const itemIndex = gameState.items.findIndex(i => i.x === newX && i.y === newY);
            if (itemIndex !== -1) {
                collectItem(itemIndex);
                // Player still moves to the item's position
            }
            
            // Move player
            activePiece.x = newX;
            activePiece.y = newY;
            
            // Add move message with coordinates
            const fromCoord = getChessCoordinates(oldX, oldY);
            const toCoord = getChessCoordinates(newX, newY);
            addMessage(`${activePiece.type} moved from ${fromCoord} to ${toCoord}`);
            
            // Enemy turn
            gameState.currentTurn = 'enemy';
            setTimeout(() => {
            moveEnemies();
                gameState.currentTurn = 'player';
            renderBoard();
            updateUI();
            }, 500);
        }
        
        // Select a piece from player's collection
        function selectPiece(pieceIndex) {
            if (pieceIndex >= 0 && pieceIndex < gameState.player.pieces.length) {
                const piece = gameState.player.pieces[pieceIndex];
                if (!piece.alive) {
                    addMessage("This piece is dead!");
                    return;
                }
                gameState.player.activePieceIndex = pieceIndex;
                addMessage(`Selected ${piece.type} piece!`);
                // Не вызываем renderBoard и updateUI здесь!
            }
        }
        
        // Generate character select screen
        function generateCharacterSelect() {
            const characterGrid = document.getElementById('character-select-grid');
            characterGrid.innerHTML = '';
            
            const characterData = [
                { 
                    key: 'pawn', 
                    symbol: '♙', 
                    name: 'Pawn', 
                    description: 'Basic piece, can promote after 5 kills',
                    stats: { mobility: 4, power: 1, special: 'Promotion' }
                },
                { 
                    key: 'knight', 
                    symbol: '♘', 
                    name: 'Knight', 
                    description: 'Jumps over obstacles in L-shape',
                    stats: { mobility: 8, power: 3, special: 'Jump' }
                },
                { 
                    key: 'bishop', 
                    symbol: '♗', 
                    name: 'Bishop', 
                    description: 'Bishops move diagonally across the board. They can travel any number of squares along a diagonal, making them powerful for controlling long diagonals.',
                    stats: { mobility: 13, power: 3, special: 'Diagonal' },
                    unlockInfo: 'Complete level 15 to unlock the Bishop'
                },
                { 
                    key: 'rook', 
                    symbol: '♖', 
                    name: 'Rook', 
                    description: 'Rooks move in straight lines horizontally and vertically. They can travel any number of squares along a rank or file, making them excellent for controlling open files.',
                    stats: { mobility: 14, power: 5, special: 'Linear' },
                    unlockInfo: 'Promote 5 pawns to unlock the Rook'
                },
                { 
                    key: 'queen', 
                    symbol: '♕', 
                    name: 'Queen', 
                    description: 'The most powerful piece in chess. Queens combine the movements of both bishops and rooks, allowing them to move any number of squares diagonally, horizontally, or vertically.',
                    stats: { mobility: 27, power: 9, special: 'Royal' },
                    unlockInfo: 'Complete level 25 to unlock the Queen'
                },
                { 
                    key: 'king', 
                    symbol: '♔', 
                    name: 'King', 
                    description: 'The royal piece. Kings move one square in any direction. While not the most mobile piece, the king is the most important - protect it at all costs!',
                    stats: { mobility: 8, power: 10, special: 'Royal' },
                    unlockInfo: 'Promote 3 pawns to unlock the King'
                }
            ];
            
            characterData.forEach((char, index) => {
                const achievement = achievements[char.key];
                const isUnlocked = achievement.unlocked;
                
                const characterDiv = document.createElement('div');
                characterDiv.className = `character ${isUnlocked ? '' : 'locked'}`;
                characterDiv.dataset.piece = char.key;
                
                characterDiv.innerHTML = `
                    <div class="character-image">
                        ${char.symbol}
                    </div>
                    <div class="character-name">${char.name}</div>
                    ${!isUnlocked ? `<div class="character-requirement">${achievement.description}</div>` : ''}
                `;
                
                // Add click event for all characters (both locked and unlocked)
                characterDiv.addEventListener('click', function() {
                    showCharacterPreview(char.key);
                });
                
                characterGrid.appendChild(characterDiv);
            });
            
            // Update progress indicator
            updateProgressIndicator();
        }
        
        // Update progress indicator
        function updateProgressIndicator() {
            const progressDots = document.querySelectorAll('.progress-dot');
            const characterKeys = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];
            
            characterKeys.forEach((key, index) => {
                if (achievements[key].unlocked) {
                    progressDots[index].classList.add('unlocked');
                } else {
                    progressDots[index].classList.remove('unlocked');
                    }
                });
        }

        // Update character select screen (called when achievements are unlocked)
        function updateCharacterSelect() {
            const characterGrid = document.getElementById('character-select-grid');
            if (characterGrid) {
                generateCharacterSelect();
            }
        }

        // Show character preview
        function showCharacterPreview(characterKey) {
            const characterData = {
                pawn: { 
                    symbol: '♙', 
                    name: 'Pawn', 
                    description: 'The most basic chess piece. Pawns move forward one square at a time, but capture diagonally. After defeating 5 enemies, a pawn can be promoted to a more powerful piece.',
                    stats: { mobility: 4, power: 1, special: 'Upg.' },
                    unlockInfo: 'Available from the start'
                },
                knight: { 
                    symbol: '♘', 
                    name: 'Knight', 
                    description: 'Knights move in an L-shape: two squares in one direction, then one square perpendicular. They can jump over other pieces, making them excellent for tactical maneuvers.',
                    stats: { mobility: 8, power: 3, special: 'Jump' },
                    unlockInfo: 'Reach level 10 to unlock the Knight'
                },
                bishop: { 
                    symbol: '♗', 
                    name: 'Bishop', 
                    description: 'Bishops move diagonally across the board. They can travel any number of squares along a diagonal, making them powerful for controlling long diagonals.',
                    stats: { mobility: 13, power: 3, special: 'Diagonal' },
                    unlockInfo: 'Complete level 15 to unlock the Bishop'
                },
                rook: { 
                    symbol: '♖', 
                    name: 'Rook', 
                    description: 'Rooks move in straight lines horizontally and vertically. They can travel any number of squares along a rank or file, making them excellent for controlling open files.',
                    stats: { mobility: 14, power: 5, special: 'Linear' },
                    unlockInfo: 'Promote 5 pawns to unlock the Rook'
                },
                queen: { 
                    symbol: '♕', 
                    name: 'Queen', 
                    description: 'The most powerful piece in chess. Queens combine the movements of both bishops and rooks, allowing them to move any number of squares diagonally, horizontally, or vertically.',
                    stats: { mobility: 27, power: 9, special: 'Royal' },
                    unlockInfo: 'Complete level 25 to unlock the Queen'
                },
                king: { 
                    symbol: '♔', 
                    name: 'King', 
                    description: 'The royal piece. Kings move one square in any direction. While not the most mobile piece, the king is the most important - protect it at all costs!',
                    stats: { mobility: 8, power: 10, special: 'Royal' },
                    unlockInfo: 'Complete level 20 to unlock the King'
                }
            };
            
            const char = characterData[characterKey];
            const achievement = achievements[characterKey];
            const isUnlocked = achievement.unlocked;
            
            // Update preview content
            document.getElementById('preview-character-image').textContent = char.symbol;
            document.getElementById('preview-character-name').textContent = char.name;
            document.getElementById('preview-character-description').textContent = char.description;
            
            // Update stats
            const statsContainer = document.getElementById('preview-character-stats');
            statsContainer.innerHTML = `
                <div class="preview-stat-item">
                    <div class="preview-stat-value">${char.stats.mobility}</div>
                    <div class="preview-stat-label">Moves</div>
                </div>
                <div class="preview-stat-item">
                    <div class="preview-stat-value">${char.stats.power}</div>
                    <div class="preview-stat-label">Power</div>
                </div>
                <div class="preview-stat-item">
                    <div class="preview-stat-value">${char.stats.special}</div>
                    <div class="preview-stat-label">Special</div>
                </div>
            `;
            
            // Show/hide unlock info
            const unlockInfo = document.getElementById('preview-unlock-info');
            const unlockDescription = document.getElementById('preview-unlock-description');
            const startButton = document.getElementById('preview-start');
            
            if (isUnlocked) {
                unlockInfo.style.display = 'none';
                unlockDescription.textContent = char.unlockInfo;
                startButton.disabled = false;
                startButton.textContent = 'Start';
                } else {
                unlockInfo.style.display = 'block';
                unlockDescription.textContent = char.unlockInfo;
                startButton.disabled = true;
                startButton.textContent = 'Locked';
            }
            
            // Store selected character for start button
            startButton.dataset.character = characterKey;
            
            // Show preview modal
            document.getElementById('character-preview').style.display = 'flex';
            // Create floating pieces for character preview
            createFloatingPieces(document.getElementById('character-preview'));
            showInterstitialAd();
            }
        
        // Hide character preview
        function hideCharacterPreview() {
            document.getElementById('character-preview').style.display = 'none';
        }

        // Проверить, активен ли постоянный эффект
        function isPermanentEffectActive(effectId) {
            return gameState.effects.permanent.includes(effectId);
        }

        // Получить общий множитель для золота
        function getGoldMultiplier() {
            let multiplier = 1.0;
            gameState.effects.permanent.forEach(effectId => {
                const effect = permanentEffects.find(e => e.id === effectId);
                if (effect && effect.id === 'gold_boost') {
                    multiplier += effect.value;
                }
            });
            return multiplier;
        }

        // Получить общий множитель для очков
        function getScoreMultiplier() {
            let multiplier = 1.0;
            gameState.effects.permanent.forEach(effectId => {
                const effect = permanentEffects.find(e => e.id === effectId);
                if (effect && effect.id === 'score_boost') {
                    multiplier += effect.value;
                }
            });
            return multiplier;
        }

        // Получить общую скидку/надбавку для магазина
        function getShopPriceModifier() {
            let modifier = 1.0;
            gameState.effects.permanent.forEach(effectId => {
                const effect = permanentEffects.find(e => e.id === effectId);
                if (effect && (effect.id === 'shop_discount' || effect.id === 'shop_markup')) {
                    if (effect.id === 'shop_discount') {
                        modifier -= effect.value;
                } else {
                        modifier += effect.value;
                    }
                }
            });
            return Math.max(0.5, Math.min(2.0, modifier)); // Ограничиваем от 50% до 200%
        }

        // Товары магазина
        const shopItems = [
            {
                id: 'shop_pawn',
                name: 'Pawn',
                description: 'Add a pawn to your collection',
                symbol: '♙',
                color: 'green',
                price: 20,
                effect: 'add_piece',
                value: 'pawn'
            },
            {
                id: 'shop_knight',
                name: 'Knight',
                description: 'Add a knight to your collection',
                symbol: '♘',
                color: 'blue',
                price: 50,
                effect: 'add_piece',
                value: 'knight'
            },
            {
                id: 'shop_bishop',
                name: 'Bishop',
                description: 'Add a bishop to your collection',
                symbol: '♗',
                color: 'cyan',
                price: 60,
                effect: 'add_piece',
                value: 'bishop'
            },
            {
                id: 'shop_rook',
                name: 'Rook',
                description: 'Add a rook to your collection',
                symbol: '♖',
                color: 'orange',
                price: 80,
                effect: 'add_piece',
                value: 'rook'
            },
            {
                id: 'shop_queen',
                name: 'Queen',
                description: 'Add a queen to your collection',
                symbol: '♕',
                color: 'purple',
                price: 150,
                effect: 'add_piece',
                value: 'queen'
            },
            {
                id: 'shop_gold_boost',
                name: 'Gold Magnet',
                description: 'Permanent +10% gold gain',
                symbol: '💰',
                color: 'gold',
                price: 100,
                effect: 'permanent_effect',
                value: 'gold_boost'
            },
            {
                id: 'shop_score_boost',
                name: 'Score Multiplier',
                description: 'Permanent +10% score gain',
                symbol: '📈',
                color: 'green',
                price: 120,
                effect: 'permanent_effect',
                value: 'score_boost'
            },
            {
                id: 'shop_heal',
                name: 'Revive Piece',
                description: 'Revive a dead piece',
                symbol: '💚',
                color: 'lime',
                price: 75,
                effect: 'revive_piece',
                value: null
            }
        ];
        
        // Функции для работы с магазином
        function generateShop() {
            const shopItemsContainer = document.getElementById('shop-items');
            const shopGoldElement = document.getElementById('shop-gold');
            
            // Обновляем золото игрока
            shopGoldElement.textContent = gameState.player.gold;
            
            // Очищаем контейнер
            shopItemsContainer.innerHTML = '';
            
            // Выбираем 4 случайных товара
            const availableItems = [...shopItems];
            const selectedItems = [];
            
            for (let i = 0; i < 4 && availableItems.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableItems.length);
                selectedItems.push(availableItems[randomIndex]);
                availableItems.splice(randomIndex, 1);
            }
            
            // Создаем элементы товаров
            selectedItems.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'shop-item';
                itemElement.style.border = '2px solid #666';
                itemElement.style.borderRadius = '8px';
                itemElement.style.padding = '10px';
                itemElement.style.textAlign = 'center';
                itemElement.style.cursor = 'pointer';
                itemElement.style.transition = 'all 0.3s ease';
                
                const priceModifier = getShopPriceModifier();
                const actualPrice = Math.floor(item.price * priceModifier);
                const canAfford = gameState.player.gold >= actualPrice;
                
                itemElement.style.backgroundColor = canAfford ? '#2a2a2a' : '#1a1a1a';
                itemElement.style.opacity = canAfford ? '1' : '0.6';
                
                itemElement.innerHTML = `
                    <div style="font-size: 24px; color: ${item.color}; margin-bottom: 5px;">
                        ${item.effect === 'permanent_effect' || item.effect === 'revive_piece' ? 
                            `<img src="${item.effect === 'permanent_effect' ? getEffectSprite(item.value) : 'assets/sprites/items/revive.png'}" style="width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated;">` : 
                            item.symbol}
                    </div>
                    <div style="font-size: 12px; font-weight: bold; color: #fff; margin-bottom: 3px;">${item.name}</div>
                    <div style="font-size: 8px; color: #ccc; margin-bottom: 5px;">${item.description}</div>
                    <div style="font-size: 10px; color: ${canAfford ? 'gold' : '#666'}; font-weight: bold;">${actualPrice} gold</div>
                `;
                
                if (canAfford) {
                    itemElement.addEventListener('click', () => buyShopItem(item));
                    itemElement.addEventListener('mouseenter', () => {
                        itemElement.style.transform = 'scale(1.05)';
                        itemElement.style.borderColor = '#888';
                    });
                itemElement.addEventListener('mouseleave', () => {
                        itemElement.style.transform = 'scale(1)';
                        itemElement.style.borderColor = '#666';
                    });
                }
                
                shopItemsContainer.appendChild(itemElement);
            });
        }
        
        function buyShopItem(item) {
            const priceModifier = getShopPriceModifier();
            const actualPrice = Math.floor(item.price * priceModifier);
            
            if (gameState.player.gold >= actualPrice) {
                gameState.player.gold -= actualPrice;
                
                // Применяем эффект товара
                switch (item.effect) {
                    case 'add_piece':
                        // Ищем свободную позицию
                        let newX, newY;
                        let attempts = 0;
                        let isOccupied;
                        do {
                            newX = Math.floor(Math.random() * gameState.boardSize);
                            newY = Math.floor(Math.random() * gameState.boardSize);
                            attempts++;
                            
                            isOccupied = gameState.enemies.some(e => e.x === newX && e.y === newY) ||
                                              gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY) ||
                                              gameState.items.some(item => item.x === newX && item.y === newY) ||
                                              (newX === gameState.exit.x && newY === gameState.exit.y);
                        } while (isOccupied && attempts < 50);
                        
                        if (attempts < 50) {
                            gameState.player.pieces.push({ 
                                type: item.value, 
                                x: newX, 
                                y: newY, 
                                alive: true, 
                                isActive: false 
                            });
                            addMessage(`Bought ${item.name}! Added to your collection.`);
                        } else {
                            addMessage(`Bought ${item.name}! No space on board - converted to gold.`);
                            gameState.player.gold += 10;
                        }
                        break;
                        
                    case 'permanent_effect':
                        applyPermanentEffect(item.value);
                        break;
                        
                    case 'revive_piece':
                        const deadPieces = gameState.player.pieces.filter(p => !p.alive);
                        if (deadPieces.length > 0) {
                            const randomDeadPiece = deadPieces[Math.floor(Math.random() * deadPieces.length)];
                            randomDeadPiece.alive = true;
                            addMessage(`Revived a ${randomDeadPiece.type}!`);
                    } else {
                            addMessage("No dead pieces to revive - converted to gold.");
                            gameState.player.gold += 25;
                        }
                        break;
                }
                
                // Обновляем магазин
                generateShop();
            }
        }
        
        function showShop() {
            generateShop();
            document.getElementById('shop-modal').classList.add('flex');
        }
        
        // Функции для работы с автоматом
        function showSlotMachine() {
            document.getElementById('slot-machine-modal').classList.add('flex');
            document.getElementById('slot-gold').textContent = gameState.player.gold;
            
            // Обновляем состояние кнопки SPIN
            const spinButton = document.getElementById('slot-spin');
            const canAfford = gameState.player.gold >= 10;
            
            if (canAfford) {
                spinButton.disabled = false;
                spinButton.style.opacity = '1';
                spinButton.style.cursor = 'pointer';
            } else {
                spinButton.disabled = true;
                spinButton.style.opacity = '0.5';
                spinButton.style.cursor = 'not-allowed';
            }
        }
        
        function spinSlotMachine() {
            if (gameState.player.gold < 10) {
                addMessage("Not enough gold for slot machine!");
                return;
            }
            
            gameState.player.gold -= 10;
            
            // Обновляем отображение золота
            document.getElementById('slot-gold').textContent = gameState.player.gold;
            
            // Показываем анимацию вращения для 3 барабанов
            const symbols = ['♘', '♗', '♖', '♕', 'gold', 'score', 'random'];
            const reels = [
                document.getElementById('slot-reel-1'),
                document.getElementById('slot-reel-2'),
                document.getElementById('slot-reel-3')
            ];
            
            let spinCount = 0;
            const maxSpins = 15; // Увеличиваем количество вращений
            
            const spinInterval = setInterval(() => {
                // Вращаем все 3 барабана
                reels.forEach((reel, index) => {
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    
                    // Если это спрайт, используем изображение
                    if (['gold', 'score', 'random'].includes(randomSymbol)) {
                        const imgElement = document.createElement('img');
                        imgElement.src = getSlotSprite(randomSymbol);
                        imgElement.style.width = '100%';
                        imgElement.style.height = '100%';
                        imgElement.style.objectFit = 'contain';
                        imgElement.style.imageRendering = 'pixelated';
                        reel.innerHTML = '';
                        reel.appendChild(imgElement);
                    } else {
                        // Если это символ фигуры, используем текст
                        reel.innerHTML = randomSymbol;
                    }
                    
                    // Добавляем эффект вращения
                    reel.style.transform = `rotateY(${Math.random() * 360}deg)`;
                });
                
                spinCount++;
                
                if (spinCount >= maxSpins) {
                    clearInterval(spinInterval);
                    
                    // Определяем результаты для каждого барабана
                    const results = [
                        determineSlotResult(),
                        determineSlotResult(),
                        determineSlotResult()
                    ];
                    
                    // Показываем финальные результаты
                    reels.forEach((reel, index) => {
                        const result = results[index];
                        
                        // Если это спрайт, используем изображение
                        if (['gold', 'score', 'random'].includes(result.symbol)) {
                            const imgElement = document.createElement('img');
                            imgElement.src = getSlotSprite(result.symbol);
                            imgElement.style.width = '100%';
                            imgElement.style.height = '100%';
                            imgElement.style.objectFit = 'contain';
                            imgElement.style.imageRendering = 'pixelated';
                            reel.innerHTML = '';
                            reel.appendChild(imgElement);
                        } else {
                            // Если это символ фигуры, используем текст
                            reel.innerHTML = result.symbol;
                        reel.style.color = result.color;
                        }
                        
                        reel.style.transform = 'rotateY(0deg)';
                    });
                    
                    // Проверяем комбинации
                    checkSlotCombination(results);
                    
                    // Обновляем кнопку спина
                    const spinButton = document.getElementById('slot-spin');
                    const canAfford = gameState.player.gold >= 10;
                    
                    if (canAfford) {
                        spinButton.disabled = false;
                        spinButton.style.opacity = '1';
                        spinButton.style.cursor = 'pointer';
                    } else {
                        spinButton.disabled = true;
                        spinButton.style.opacity = '0.5';
                        spinButton.style.cursor = 'not-allowed';
                    }
                }
            }, 100);
        }
        
        function determineSlotResult() {
            const random = Math.random();
            
            if (random < 0.4) {
                // 40% - конь
                return { type: 'piece', value: 'knight', symbol: '♘', color: 'blue', name: 'Knight' };
            } else if (random < 0.6) {
                // 20% - слон
                return { type: 'piece', value: 'bishop', symbol: '♗', color: 'cyan', name: 'Bishop' };
            } else if (random < 0.75) {
                // 15% - ладья
                return { type: 'piece', value: 'rook', symbol: '♖', color: 'orange', name: 'Rook' };
            } else if (random < 0.85) {
                // 10% - ферзь
                return { type: 'piece', value: 'queen', symbol: '♕', color: 'purple', name: 'Queen' };
            } else if (random < 0.92) {
                // 7% - золото
                return { type: 'gold', value: 50, symbol: 'gold', color: 'gold', name: 'Gold' };
            } else if (random < 0.96) {
                // 4% - очки
                return { type: 'score', value: 200, symbol: 'score', color: 'green', name: 'Score' };
            } else {
                // 4% - случайный эффект
                return { type: 'effect', value: 'random', symbol: 'random', color: 'yellow', name: 'Random Effect' };
            }
        }
        
        function applySlotResult(result) {
            switch (result.type) {
                case 'piece':
                    // Ищем свободную позицию
                    let newX, newY;
                    let attempts = 0;
                    let isOccupied;
                    do {
                        newX = Math.floor(Math.random() * gameState.boardSize);
                        newY = Math.floor(Math.random() * gameState.boardSize);
                        attempts++;
                        
                        isOccupied = gameState.enemies.some(e => e.x === newX && e.y === newY) ||
                                          gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY) ||
                                          gameState.items.some(item => item.x === newX && item.y === newY) ||
                                          (newX === gameState.exit.x && newY === gameState.exit.y);
                    } while (isOccupied && attempts < 50);
                    
                    if (attempts < 50) {
                        gameState.player.pieces.push({ 
                            type: result.value, 
                            x: newX, 
                            y: newY, 
                            alive: true, 
                            isActive: false 
                        });
                        addMessage(`🎰 Won ${result.name}! Added to your collection.`);
                    } else {
                        addMessage(`🎰 Won ${result.name}! No space on board - converted to gold.`);
                        gameState.player.gold += 15;
                    }
                    break;
                    
                case 'gold':
                    gameState.player.gold += result.value;
                    addMessage(`🎰 Won ${result.value} gold!`);
                    break;
                    
                case 'score':
                    gameState.score += result.value;
                    addMessage(`🎰 Won ${result.value} points!`);
                    break;
                    
                case 'effect':
                    const randomEffect = temporaryEffects[Math.floor(Math.random() * temporaryEffects.length)];
                    applyTemporaryEffect(randomEffect.id);
                    addMessage(`🎰 Won random effect: ${randomEffect.name}!`);
                    break;
            }
            
            // Обновляем UI
                    updateUI();
        }

        document.getElementById('shop-slot').addEventListener('click', showSlotMachine);
        document.getElementById('slot-spin').addEventListener('click', spinSlotMachine);
        document.getElementById('slot-close').addEventListener('click', () => {
            document.getElementById('slot-machine-modal').classList.remove('flex');
            
            // Обновляем отображение золота в магазине
            if (document.getElementById('shop-gold')) {
                document.getElementById('shop-gold').textContent = gameState.player.gold;
            }
        });

        function checkSlotCombination(results) {
            // Проверяем различные комбинации
            const symbols = results.map(r => r.symbol);
            
            // Определяем типы символов
            const pieceSymbols = ['♘', '♗', '♖', '♕'];
            const effectSymbols = ['gold', 'score', 'random'];
            
            // Проверяем на тройное совпадение
            if (symbols[0] === symbols[1] && symbols[1] === symbols[2]) {
                addMessage("🎰 JACKPOT! Triple match!");
                
                // Если это фигура - даем эту фигуру
                if (pieceSymbols.includes(symbols[0])) {
                    const pieceResult = results[0];
                    addRandomPiece(pieceResult.value);
                    showSlotPrize('jackpot', pieceResult.symbol, pieceResult.name);
                }
                // Если это эффект - даем этот эффект
                else if (effectSymbols.includes(symbols[0])) {
                    const effectResult = results[0];
                    if (effectResult.type === 'gold') {
                        gameState.player.gold += effectResult.value;
                        showSlotPrize('jackpot', effectResult.value, 'gold');
                    } else if (effectResult.type === 'score') {
                        gameState.score += effectResult.value;
                        showSlotPrize('jackpot', effectResult.value, 'points');
                    } else if (effectResult.type === 'effect') {
                        const randomEffect = temporaryEffects[Math.floor(Math.random() * temporaryEffects.length)];
                        applyTemporaryEffect(randomEffect.id);
                        showSlotPrize('jackpot', '⭐', randomEffect.name);
                    }
                }
            }
            // Проверяем на двойное совпадение фигур
            else if ((symbols[0] === symbols[1] && pieceSymbols.includes(symbols[0])) ||
                     (symbols[1] === symbols[2] && pieceSymbols.includes(symbols[1])) ||
                     (symbols[0] === symbols[2] && pieceSymbols.includes(symbols[0]))) {
                addMessage("🎰 Double pieces! You get a pawn!");
                addRandomPiece('pawn');
                showSlotPrize('pawn', '♙', 'pawn');
            }
            // Проверяем на двойное совпадение эффектов
            else if ((symbols[0] === symbols[1] && effectSymbols.includes(symbols[0])) ||
                     (symbols[1] === symbols[2] && effectSymbols.includes(symbols[1])) ||
                     (symbols[0] === symbols[2] && effectSymbols.includes(symbols[0]))) {
                addMessage("🎰 Double effects! You get 5 gold!");
                gameState.player.gold += 5;
                showSlotPrize('gold', 5, 'gold');
            }
            // Нет совпадений - обычная награда
            else {
                addMessage("🎰 No match! Try again!");
                // Никакой приз не выдаётся
            }
            
            // Обновляем UI
                    updateUI();
        }
        
        function addRandomPiece(pieceType) {
            // Ищем свободную позицию
            let newX, newY;
            let attempts = 0;
            let isOccupied;
            do {
                newX = Math.floor(Math.random() * gameState.boardSize);
                newY = Math.floor(Math.random() * gameState.boardSize);
                attempts++;
                
                isOccupied = gameState.enemies.some(e => e.x === newX && e.y === newY) ||
                                  gameState.player.pieces.some(p => p.alive && p.x === newX && p.y === newY) ||
                                  gameState.items.some(item => item.x === newX && item.y === newY) ||
                                  (newX === gameState.exit.x && newY === gameState.exit.y);
            } while (isOccupied && attempts < 50);
            
            if (attempts < 50) {
                gameState.player.pieces.push({ 
                    type: pieceType, 
                    x: newX, 
                    y: newY, 
                    alive: true, 
                    isActive: false 
                });
            } else {
                // Если нет места, даем золото
                gameState.player.gold += 10;
            }
        }

        function startNewGame() {
            gameState = {
                boardSize: 8,
                player: {
                    pieces: [
                        { type: selectedCharacter, x: 0, y: 0, alive: true, isActive: false }
                    ],
                    gold: 0,
                    inventory: []
                },
                enemies: [],
                items: [],
                exit: { x: 7, y: 7 },
                level: 1,
                score: 0,
                gamePhase: 'playing',
                selectedPiece: null,
                turn: 'player',
                temporaryEffects: [],
                permanentEffects: [],
                oneTimeEffects: []
            };
            
            generateLevel();
            updateUI();
            showGameScreen();
        }

        function showSlotPrize(prizeType, prizeValue, prizeName) {
            const prizeContent = document.getElementById('prize-content');
            const prizeText = document.getElementById('prize-text');
            
            // Устанавливаем символ и текст приза
            switch (prizeType) {
                case 'piece':
                    prizeContent.textContent = prizeValue;
                    prizeText.textContent = `You won a ${prizeName}!`;
                    break;
                case 'gold':
                    // Используем спрайт для золота
                    const goldImg = document.createElement('img');
                    goldImg.src = getSlotSprite('gold');
                    goldImg.style.width = '100%';
                    goldImg.style.height = '100%';
                    goldImg.style.objectFit = 'contain';
                    goldImg.style.imageRendering = 'pixelated';
                    prizeContent.innerHTML = '';
                    prizeContent.appendChild(goldImg);
                    prizeText.textContent = `You won ${prizeValue} gold!`;
                    break;
                case 'score':
                    // Используем спрайт для очков
                    const scoreImg = document.createElement('img');
                    scoreImg.src = getSlotSprite('score');
                    scoreImg.style.width = '100%';
                    scoreImg.style.height = '100%';
                    scoreImg.style.objectFit = 'contain';
                    scoreImg.style.imageRendering = 'pixelated';
                    prizeContent.innerHTML = '';
                    prizeContent.appendChild(scoreImg);
                    prizeText.textContent = `You won ${prizeValue} points!`;
                    break;
                case 'effect':
                    // Используем спрайт для случайного эффекта
                    const randomImg = document.createElement('img');
                    randomImg.src = getSlotSprite('random');
                    randomImg.style.width = '100%';
                    randomImg.style.height = '100%';
                    randomImg.style.objectFit = 'contain';
                    randomImg.style.imageRendering = 'pixelated';
                    prizeContent.innerHTML = '';
                    prizeContent.appendChild(randomImg);
                    prizeText.textContent = `You won: ${prizeName}!`;
                    break;
                case 'pawn':
                    prizeContent.textContent = '♙';
                    prizeText.textContent = 'You won a pawn!';
                    break;
                case 'jackpot':
                    // Используем спрайт слот-машины для джекпота
                    const jackpotImg = document.createElement('img');
                    jackpotImg.src = getItemSprite('slot');
                    jackpotImg.style.width = '100%';
                    jackpotImg.style.height = '100%';
                    jackpotImg.style.objectFit = 'contain';
                    jackpotImg.style.imageRendering = 'pixelated';
                    prizeContent.innerHTML = '';
                    prizeContent.appendChild(jackpotImg);
                    prizeText.textContent = `JACKPOT! ${prizeName}`;
                    break;
                default:
                    prizeContent.textContent = '🎁';
                    prizeText.textContent = 'You won a prize!';
            }
            
            // Показываем окно приза
            document.getElementById('slot-prize-modal').classList.add('flex');
        }
        
        // Обработчик закрытия окна приза
        document.getElementById('prize-close').addEventListener('click', () => {
            document.getElementById('slot-prize-modal').classList.remove('flex');
        });

        // Create animated floating pieces for modal background
        function createFloatingPieces(container) {
            if (!container) return;
            
            const pieces = [
                { type: 'king', color: 'white', top: '10%', left: '5%' },
                { type: 'queen', color: 'black', top: '15%', right: '8%' },
                { type: 'rook', color: 'white', top: '25%', left: '15%' },
                { type: 'bishop', color: 'black', top: '30%', right: '20%' },
                { type: 'knight', color: 'white', top: '45%', left: '8%' },
                { type: 'pawn', color: 'black', top: '50%', right: '12%' },
                { type: 'bishop', color: 'white', top: '65%', left: '25%' },
                { type: 'knight', color: 'black', top: '70%', right: '5%' },
                { type: 'queen', color: 'white', top: '80%', left: '10%' },
                { type: 'king', color: 'black', top: '85%', right: '18%' },
                { type: 'pawn', color: 'white', top: '90%', left: '30%' },
                { type: 'rook', color: 'black', top: '95%', right: '30%' }
            ];
            
            pieces.forEach(piece => {
                const pieceElement = document.createElement('div');
                pieceElement.className = `floating-piece ${piece.color} ${piece.type}`;
                pieceElement.style.top = piece.top;
                if (piece.left) pieceElement.style.left = piece.left;
                if (piece.right) pieceElement.style.right = piece.right;
                
                const imgElement = document.createElement('img');
                imgElement.src = `assets/sprites/figures/${piece.color}/${piece.type}.png`;
                imgElement.alt = `${piece.color} ${piece.type}`;
                imgElement.style.width = '100%';
                imgElement.style.height = '100%';
                imgElement.style.objectFit = 'contain';
                
                pieceElement.appendChild(imgElement);
                container.appendChild(pieceElement);
            });
        }

        // Clear floating pieces from modal
        function clearFloatingPieces(container) {
            if (!container) return;
            const floatingPieces = container.querySelectorAll('.floating-piece');
            floatingPieces.forEach(piece => piece.remove());
        }

        // Show unlock notification
        function showUnlockNotification() {
            // Создаем модальное окно уведомления
            const notification = document.createElement('div');
            notification.className = 'unlock-notification';
            notification.innerHTML = `
                <div class="unlock-content">
                    <div class="unlock-icon">🎉</div>
                    <div class="unlock-title">NEW CHARACTER UNLOCKED!</div>
                    <div class="unlock-message">A new piece is now available in character select!</div>
                    <button class="unlock-button" onclick="this.parentElement.parentElement.remove()">OK</button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Автоматически убираем через 5 секунд
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // Проверяем доступность rewarded рекламы
        if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
            window.cordova.plugins.adPlugin.isRewardedAdReady().then((result) => {
                const reviveBtn = document.getElementById('revive-button');
                if (result && result.ready) {
                    reviveBtn.disabled = false;
                } else {
                    reviveBtn.disabled = true;
                }
            });
        }
        
        document.getElementById('revive-button').onclick = function() {
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.adPlugin) {
                window.cordova.plugins.adPlugin.showRewardedAd();
            }
        };
        // Слушаем событие о получении награды
        window.addEventListener('rewardedAdCompleted', function() {
            revivePlayer();
        });

        // Добавьте функцию revivePlayer(), которая восстанавливает игрока и закрывает game over.
        function revivePlayer() {
            document.getElementById('game-over-modal').classList.remove('flex');
            document.getElementById('level-complete-modal').classList.remove('flex');
            document.getElementById('in-game-menu').classList.add('hidden');
            document.getElementById('in-game-menu').classList.remove('flex');
            
            // Полностью сбрасываем состояние игры
            gameState.currentLevel = 1;
            gameState.score = 0;
            gameState.player.gold = 0;
            gameState.player.inventory = [];
            gameState.player.abilities = [];
            gameState.player.kills = 0;
            gameState.messages = [];
            // Сбрасываем эффекты
            gameState.effects.temporary = [];
            gameState.effects.permanent = [];
            gameState.effects.oneTime = [];
            
            // Сбрасываем фигуры игрока к начальному состоянию с сохранённым персонажем
            gameState.player.pieces = [
                { type: selectedCharacter, x: 0, y: 0, alive: true, isActive: true }
            ];
            gameState.player.activePieceIndex = 0;
            
            // Генерируем первый уровень
            generateLevel();
        }
    </script>
</body>
</html>